// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Invoicing/ExtendedSigner.proto

#ifndef PROTOBUF_Invoicing_2fExtendedSigner_2eproto__INCLUDED
#define PROTOBUF_Invoicing_2fExtendedSigner_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Diadoc {
namespace Api {
namespace Proto {
namespace Invoicing {
namespace Signers {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Invoicing_2fExtendedSigner_2eproto();
void protobuf_AssignDesc_Invoicing_2fExtendedSigner_2eproto();
void protobuf_ShutdownFile_Invoicing_2fExtendedSigner_2eproto();

class ExtendedSigner;
class ExtendedSignerDetails;
class ExtendedSignerDetailsToPost;

enum SignerType {
  LegalEntity = 1,
  IndividualEntity = 2,
  PhysicalPerson = 3
};
bool SignerType_IsValid(int value);
const SignerType SignerType_MIN = LegalEntity;
const SignerType SignerType_MAX = PhysicalPerson;
const int SignerType_ARRAYSIZE = SignerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SignerType_descriptor();
inline const ::std::string& SignerType_Name(SignerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SignerType_descriptor(), value);
}
inline bool SignerType_Parse(
    const ::std::string& name, SignerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignerType>(
    SignerType_descriptor(), name, value);
}
enum SignerPowers {
  InvoiceSigner = 0,
  PersonMadeOperation = 1,
  MadeAndSignOperation = 2,
  PersonDocumentedOperation = 3,
  MadeOperationAndSignedInvoice = 4,
  MadeAndResponsibleForOperationAndSignedInvoice = 5,
  ResponsibleForOperationAndSignerForInvoice = 6
};
bool SignerPowers_IsValid(int value);
const SignerPowers SignerPowers_MIN = InvoiceSigner;
const SignerPowers SignerPowers_MAX = ResponsibleForOperationAndSignerForInvoice;
const int SignerPowers_ARRAYSIZE = SignerPowers_MAX + 1;

const ::google::protobuf::EnumDescriptor* SignerPowers_descriptor();
inline const ::std::string& SignerPowers_Name(SignerPowers value) {
  return ::google::protobuf::internal::NameOfEnum(
    SignerPowers_descriptor(), value);
}
inline bool SignerPowers_Parse(
    const ::std::string& name, SignerPowers* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignerPowers>(
    SignerPowers_descriptor(), name, value);
}
enum SignerStatus {
  SellerEmployee = 1,
  InformationCreatorEmployee = 2,
  OtherOrganizationEmployee = 3,
  AuthorizedPerson = 4
};
bool SignerStatus_IsValid(int value);
const SignerStatus SignerStatus_MIN = SellerEmployee;
const SignerStatus SignerStatus_MAX = AuthorizedPerson;
const int SignerStatus_ARRAYSIZE = SignerStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* SignerStatus_descriptor();
inline const ::std::string& SignerStatus_Name(SignerStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    SignerStatus_descriptor(), value);
}
inline bool SignerStatus_Parse(
    const ::std::string& name, SignerStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignerStatus>(
    SignerStatus_descriptor(), name, value);
}
enum DocumentTitleType {
  UtdSeller = 0,
  UtdBuyer = 1,
  UcdSeller = 2,
  UcdBuyer = 3,
  TovTorg551Seller = 4,
  TovTorg551Buyer = 5,
  AccCert552Seller = 6,
  AccCert552Buyer = 7
};
bool DocumentTitleType_IsValid(int value);
const DocumentTitleType DocumentTitleType_MIN = UtdSeller;
const DocumentTitleType DocumentTitleType_MAX = AccCert552Buyer;
const int DocumentTitleType_ARRAYSIZE = DocumentTitleType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DocumentTitleType_descriptor();
inline const ::std::string& DocumentTitleType_Name(DocumentTitleType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DocumentTitleType_descriptor(), value);
}
inline bool DocumentTitleType_Parse(
    const ::std::string& name, DocumentTitleType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DocumentTitleType>(
    DocumentTitleType_descriptor(), name, value);
}
// ===================================================================

class ExtendedSigner : public ::google::protobuf::Message {
 public:
  ExtendedSigner();
  virtual ~ExtendedSigner();

  ExtendedSigner(const ExtendedSigner& from);

  inline ExtendedSigner& operator=(const ExtendedSigner& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtendedSigner& default_instance();

  void Swap(ExtendedSigner* other);

  // implements Message ----------------------------------------------

  ExtendedSigner* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExtendedSigner& from);
  void MergeFrom(const ExtendedSigner& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string BoxId = 1;
  inline bool has_boxid() const;
  inline void clear_boxid();
  static const int kBoxIdFieldNumber = 1;
  inline const ::std::string& boxid() const;
  inline void set_boxid(const ::std::string& value);
  inline void set_boxid(const char* value);
  inline void set_boxid(const char* value, size_t size);
  inline ::std::string* mutable_boxid();
  inline ::std::string* release_boxid();
  inline void set_allocated_boxid(::std::string* boxid);

  // optional bytes SignerCertificate = 2;
  inline bool has_signercertificate() const;
  inline void clear_signercertificate();
  static const int kSignerCertificateFieldNumber = 2;
  inline const ::std::string& signercertificate() const;
  inline void set_signercertificate(const ::std::string& value);
  inline void set_signercertificate(const char* value);
  inline void set_signercertificate(const void* value, size_t size);
  inline ::std::string* mutable_signercertificate();
  inline ::std::string* release_signercertificate();
  inline void set_allocated_signercertificate(::std::string* signercertificate);

  // optional string SignerCertificateThumbprint = 3;
  inline bool has_signercertificatethumbprint() const;
  inline void clear_signercertificatethumbprint();
  static const int kSignerCertificateThumbprintFieldNumber = 3;
  inline const ::std::string& signercertificatethumbprint() const;
  inline void set_signercertificatethumbprint(const ::std::string& value);
  inline void set_signercertificatethumbprint(const char* value);
  inline void set_signercertificatethumbprint(const char* value, size_t size);
  inline ::std::string* mutable_signercertificatethumbprint();
  inline ::std::string* release_signercertificatethumbprint();
  inline void set_allocated_signercertificatethumbprint(::std::string* signercertificatethumbprint);

  // optional .Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails SignerDetails = 4;
  inline bool has_signerdetails() const;
  inline void clear_signerdetails();
  static const int kSignerDetailsFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSignerDetails& signerdetails() const;
  inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSignerDetails* mutable_signerdetails();
  inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSignerDetails* release_signerdetails();
  inline void set_allocated_signerdetails(::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSignerDetails* signerdetails);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner)
 private:
  inline void set_has_boxid();
  inline void clear_has_boxid();
  inline void set_has_signercertificate();
  inline void clear_has_signercertificate();
  inline void set_has_signercertificatethumbprint();
  inline void clear_has_signercertificatethumbprint();
  inline void set_has_signerdetails();
  inline void clear_has_signerdetails();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* boxid_;
  ::std::string* signercertificate_;
  ::std::string* signercertificatethumbprint_;
  ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSignerDetails* signerdetails_;
  friend void  protobuf_AddDesc_Invoicing_2fExtendedSigner_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fExtendedSigner_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fExtendedSigner_2eproto();

  void InitAsDefaultInstance();
  static ExtendedSigner* default_instance_;
};
// -------------------------------------------------------------------

class ExtendedSignerDetails : public ::google::protobuf::Message {
 public:
  ExtendedSignerDetails();
  virtual ~ExtendedSignerDetails();

  ExtendedSignerDetails(const ExtendedSignerDetails& from);

  inline ExtendedSignerDetails& operator=(const ExtendedSignerDetails& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtendedSignerDetails& default_instance();

  void Swap(ExtendedSignerDetails* other);

  // implements Message ----------------------------------------------

  ExtendedSignerDetails* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExtendedSignerDetails& from);
  void MergeFrom(const ExtendedSignerDetails& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Surname = 1;
  inline bool has_surname() const;
  inline void clear_surname();
  static const int kSurnameFieldNumber = 1;
  inline const ::std::string& surname() const;
  inline void set_surname(const ::std::string& value);
  inline void set_surname(const char* value);
  inline void set_surname(const char* value, size_t size);
  inline ::std::string* mutable_surname();
  inline ::std::string* release_surname();
  inline void set_allocated_surname(::std::string* surname);

  // required string FirstName = 2;
  inline bool has_firstname() const;
  inline void clear_firstname();
  static const int kFirstNameFieldNumber = 2;
  inline const ::std::string& firstname() const;
  inline void set_firstname(const ::std::string& value);
  inline void set_firstname(const char* value);
  inline void set_firstname(const char* value, size_t size);
  inline ::std::string* mutable_firstname();
  inline ::std::string* release_firstname();
  inline void set_allocated_firstname(::std::string* firstname);

  // optional string Patronymic = 3;
  inline bool has_patronymic() const;
  inline void clear_patronymic();
  static const int kPatronymicFieldNumber = 3;
  inline const ::std::string& patronymic() const;
  inline void set_patronymic(const ::std::string& value);
  inline void set_patronymic(const char* value);
  inline void set_patronymic(const char* value, size_t size);
  inline ::std::string* mutable_patronymic();
  inline ::std::string* release_patronymic();
  inline void set_allocated_patronymic(::std::string* patronymic);

  // optional string JobTitle = 4;
  inline bool has_jobtitle() const;
  inline void clear_jobtitle();
  static const int kJobTitleFieldNumber = 4;
  inline const ::std::string& jobtitle() const;
  inline void set_jobtitle(const ::std::string& value);
  inline void set_jobtitle(const char* value);
  inline void set_jobtitle(const char* value, size_t size);
  inline ::std::string* mutable_jobtitle();
  inline ::std::string* release_jobtitle();
  inline void set_allocated_jobtitle(::std::string* jobtitle);

  // optional string Inn = 5;
  inline bool has_inn() const;
  inline void clear_inn();
  static const int kInnFieldNumber = 5;
  inline const ::std::string& inn() const;
  inline void set_inn(const ::std::string& value);
  inline void set_inn(const char* value);
  inline void set_inn(const char* value, size_t size);
  inline ::std::string* mutable_inn();
  inline ::std::string* release_inn();
  inline void set_allocated_inn(::std::string* inn);

  // optional string RegistrationCertificate = 6;
  inline bool has_registrationcertificate() const;
  inline void clear_registrationcertificate();
  static const int kRegistrationCertificateFieldNumber = 6;
  inline const ::std::string& registrationcertificate() const;
  inline void set_registrationcertificate(const ::std::string& value);
  inline void set_registrationcertificate(const char* value);
  inline void set_registrationcertificate(const char* value, size_t size);
  inline ::std::string* mutable_registrationcertificate();
  inline ::std::string* release_registrationcertificate();
  inline void set_allocated_registrationcertificate(::std::string* registrationcertificate);

  // required .Diadoc.Api.Proto.Invoicing.Signers.SignerType SignerType = 7 [default = LegalEntity];
  inline bool has_signertype() const;
  inline void clear_signertype();
  static const int kSignerTypeFieldNumber = 7;
  inline ::Diadoc::Api::Proto::Invoicing::Signers::SignerType signertype() const;
  inline void set_signertype(::Diadoc::Api::Proto::Invoicing::Signers::SignerType value);

  // optional string SignerOrganizationName = 8;
  inline bool has_signerorganizationname() const;
  inline void clear_signerorganizationname();
  static const int kSignerOrganizationNameFieldNumber = 8;
  inline const ::std::string& signerorganizationname() const;
  inline void set_signerorganizationname(const ::std::string& value);
  inline void set_signerorganizationname(const char* value);
  inline void set_signerorganizationname(const char* value, size_t size);
  inline ::std::string* mutable_signerorganizationname();
  inline ::std::string* release_signerorganizationname();
  inline void set_allocated_signerorganizationname(::std::string* signerorganizationname);

  // optional string SignerInfo = 9;
  inline bool has_signerinfo() const;
  inline void clear_signerinfo();
  static const int kSignerInfoFieldNumber = 9;
  inline const ::std::string& signerinfo() const;
  inline void set_signerinfo(const ::std::string& value);
  inline void set_signerinfo(const char* value);
  inline void set_signerinfo(const char* value, size_t size);
  inline ::std::string* mutable_signerinfo();
  inline ::std::string* release_signerinfo();
  inline void set_allocated_signerinfo(::std::string* signerinfo);

  // required .Diadoc.Api.Proto.Invoicing.Signers.SignerPowers SignerPowers = 10;
  inline bool has_signerpowers() const;
  inline void clear_signerpowers();
  static const int kSignerPowersFieldNumber = 10;
  inline ::Diadoc::Api::Proto::Invoicing::Signers::SignerPowers signerpowers() const;
  inline void set_signerpowers(::Diadoc::Api::Proto::Invoicing::Signers::SignerPowers value);

  // required .Diadoc.Api.Proto.Invoicing.Signers.SignerStatus SignerStatus = 11;
  inline bool has_signerstatus() const;
  inline void clear_signerstatus();
  static const int kSignerStatusFieldNumber = 11;
  inline ::Diadoc::Api::Proto::Invoicing::Signers::SignerStatus signerstatus() const;
  inline void set_signerstatus(::Diadoc::Api::Proto::Invoicing::Signers::SignerStatus value);

  // optional string SignerPowersBase = 12;
  inline bool has_signerpowersbase() const;
  inline void clear_signerpowersbase();
  static const int kSignerPowersBaseFieldNumber = 12;
  inline const ::std::string& signerpowersbase() const;
  inline void set_signerpowersbase(const ::std::string& value);
  inline void set_signerpowersbase(const char* value);
  inline void set_signerpowersbase(const char* value, size_t size);
  inline ::std::string* mutable_signerpowersbase();
  inline ::std::string* release_signerpowersbase();
  inline void set_allocated_signerpowersbase(::std::string* signerpowersbase);

  // optional string SignerOrgPowersBase = 13;
  inline bool has_signerorgpowersbase() const;
  inline void clear_signerorgpowersbase();
  static const int kSignerOrgPowersBaseFieldNumber = 13;
  inline const ::std::string& signerorgpowersbase() const;
  inline void set_signerorgpowersbase(const ::std::string& value);
  inline void set_signerorgpowersbase(const char* value);
  inline void set_signerorgpowersbase(const char* value, size_t size);
  inline ::std::string* mutable_signerorgpowersbase();
  inline ::std::string* release_signerorgpowersbase();
  inline void set_allocated_signerorgpowersbase(::std::string* signerorgpowersbase);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails)
 private:
  inline void set_has_surname();
  inline void clear_has_surname();
  inline void set_has_firstname();
  inline void clear_has_firstname();
  inline void set_has_patronymic();
  inline void clear_has_patronymic();
  inline void set_has_jobtitle();
  inline void clear_has_jobtitle();
  inline void set_has_inn();
  inline void clear_has_inn();
  inline void set_has_registrationcertificate();
  inline void clear_has_registrationcertificate();
  inline void set_has_signertype();
  inline void clear_has_signertype();
  inline void set_has_signerorganizationname();
  inline void clear_has_signerorganizationname();
  inline void set_has_signerinfo();
  inline void clear_has_signerinfo();
  inline void set_has_signerpowers();
  inline void clear_has_signerpowers();
  inline void set_has_signerstatus();
  inline void clear_has_signerstatus();
  inline void set_has_signerpowersbase();
  inline void clear_has_signerpowersbase();
  inline void set_has_signerorgpowersbase();
  inline void clear_has_signerorgpowersbase();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* surname_;
  ::std::string* firstname_;
  ::std::string* patronymic_;
  ::std::string* jobtitle_;
  ::std::string* inn_;
  ::std::string* registrationcertificate_;
  ::std::string* signerorganizationname_;
  int signertype_;
  int signerpowers_;
  ::std::string* signerinfo_;
  ::std::string* signerpowersbase_;
  ::std::string* signerorgpowersbase_;
  int signerstatus_;
  friend void  protobuf_AddDesc_Invoicing_2fExtendedSigner_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fExtendedSigner_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fExtendedSigner_2eproto();

  void InitAsDefaultInstance();
  static ExtendedSignerDetails* default_instance_;
};
// -------------------------------------------------------------------

class ExtendedSignerDetailsToPost : public ::google::protobuf::Message {
 public:
  ExtendedSignerDetailsToPost();
  virtual ~ExtendedSignerDetailsToPost();

  ExtendedSignerDetailsToPost(const ExtendedSignerDetailsToPost& from);

  inline ExtendedSignerDetailsToPost& operator=(const ExtendedSignerDetailsToPost& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtendedSignerDetailsToPost& default_instance();

  void Swap(ExtendedSignerDetailsToPost* other);

  // implements Message ----------------------------------------------

  ExtendedSignerDetailsToPost* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExtendedSignerDetailsToPost& from);
  void MergeFrom(const ExtendedSignerDetailsToPost& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string JobTitle = 1;
  inline bool has_jobtitle() const;
  inline void clear_jobtitle();
  static const int kJobTitleFieldNumber = 1;
  inline const ::std::string& jobtitle() const;
  inline void set_jobtitle(const ::std::string& value);
  inline void set_jobtitle(const char* value);
  inline void set_jobtitle(const char* value, size_t size);
  inline ::std::string* mutable_jobtitle();
  inline ::std::string* release_jobtitle();
  inline void set_allocated_jobtitle(::std::string* jobtitle);

  // optional string RegistrationCertificate = 2;
  inline bool has_registrationcertificate() const;
  inline void clear_registrationcertificate();
  static const int kRegistrationCertificateFieldNumber = 2;
  inline const ::std::string& registrationcertificate() const;
  inline void set_registrationcertificate(const ::std::string& value);
  inline void set_registrationcertificate(const char* value);
  inline void set_registrationcertificate(const char* value, size_t size);
  inline ::std::string* mutable_registrationcertificate();
  inline ::std::string* release_registrationcertificate();
  inline void set_allocated_registrationcertificate(::std::string* registrationcertificate);

  // required .Diadoc.Api.Proto.Invoicing.Signers.SignerType SignerType = 3;
  inline bool has_signertype() const;
  inline void clear_signertype();
  static const int kSignerTypeFieldNumber = 3;
  inline ::Diadoc::Api::Proto::Invoicing::Signers::SignerType signertype() const;
  inline void set_signertype(::Diadoc::Api::Proto::Invoicing::Signers::SignerType value);

  // optional string SignerInfo = 4;
  inline bool has_signerinfo() const;
  inline void clear_signerinfo();
  static const int kSignerInfoFieldNumber = 4;
  inline const ::std::string& signerinfo() const;
  inline void set_signerinfo(const ::std::string& value);
  inline void set_signerinfo(const char* value);
  inline void set_signerinfo(const char* value, size_t size);
  inline ::std::string* mutable_signerinfo();
  inline ::std::string* release_signerinfo();
  inline void set_allocated_signerinfo(::std::string* signerinfo);

  // required .Diadoc.Api.Proto.Invoicing.Signers.SignerPowers SignerPowers = 5;
  inline bool has_signerpowers() const;
  inline void clear_signerpowers();
  static const int kSignerPowersFieldNumber = 5;
  inline ::Diadoc::Api::Proto::Invoicing::Signers::SignerPowers signerpowers() const;
  inline void set_signerpowers(::Diadoc::Api::Proto::Invoicing::Signers::SignerPowers value);

  // required .Diadoc.Api.Proto.Invoicing.Signers.SignerStatus SignerStatus = 6;
  inline bool has_signerstatus() const;
  inline void clear_signerstatus();
  static const int kSignerStatusFieldNumber = 6;
  inline ::Diadoc::Api::Proto::Invoicing::Signers::SignerStatus signerstatus() const;
  inline void set_signerstatus(::Diadoc::Api::Proto::Invoicing::Signers::SignerStatus value);

  // optional string SignerPowersBase = 7;
  inline bool has_signerpowersbase() const;
  inline void clear_signerpowersbase();
  static const int kSignerPowersBaseFieldNumber = 7;
  inline const ::std::string& signerpowersbase() const;
  inline void set_signerpowersbase(const ::std::string& value);
  inline void set_signerpowersbase(const char* value);
  inline void set_signerpowersbase(const char* value, size_t size);
  inline ::std::string* mutable_signerpowersbase();
  inline ::std::string* release_signerpowersbase();
  inline void set_allocated_signerpowersbase(::std::string* signerpowersbase);

  // optional string SignerOrgPowersBase = 8;
  inline bool has_signerorgpowersbase() const;
  inline void clear_signerorgpowersbase();
  static const int kSignerOrgPowersBaseFieldNumber = 8;
  inline const ::std::string& signerorgpowersbase() const;
  inline void set_signerorgpowersbase(const ::std::string& value);
  inline void set_signerorgpowersbase(const char* value);
  inline void set_signerorgpowersbase(const char* value, size_t size);
  inline ::std::string* mutable_signerorgpowersbase();
  inline ::std::string* release_signerorgpowersbase();
  inline void set_allocated_signerorgpowersbase(::std::string* signerorgpowersbase);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost)
 private:
  inline void set_has_jobtitle();
  inline void clear_has_jobtitle();
  inline void set_has_registrationcertificate();
  inline void clear_has_registrationcertificate();
  inline void set_has_signertype();
  inline void clear_has_signertype();
  inline void set_has_signerinfo();
  inline void clear_has_signerinfo();
  inline void set_has_signerpowers();
  inline void clear_has_signerpowers();
  inline void set_has_signerstatus();
  inline void clear_has_signerstatus();
  inline void set_has_signerpowersbase();
  inline void clear_has_signerpowersbase();
  inline void set_has_signerorgpowersbase();
  inline void clear_has_signerorgpowersbase();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* jobtitle_;
  ::std::string* registrationcertificate_;
  ::std::string* signerinfo_;
  int signertype_;
  int signerpowers_;
  ::std::string* signerpowersbase_;
  ::std::string* signerorgpowersbase_;
  int signerstatus_;
  friend void  protobuf_AddDesc_Invoicing_2fExtendedSigner_2eproto();
  friend void protobuf_AssignDesc_Invoicing_2fExtendedSigner_2eproto();
  friend void protobuf_ShutdownFile_Invoicing_2fExtendedSigner_2eproto();

  void InitAsDefaultInstance();
  static ExtendedSignerDetailsToPost* default_instance_;
};
// ===================================================================


// ===================================================================

// ExtendedSigner

// optional string BoxId = 1;
inline bool ExtendedSigner::has_boxid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtendedSigner::set_has_boxid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtendedSigner::clear_has_boxid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtendedSigner::clear_boxid() {
  if (boxid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    boxid_->clear();
  }
  clear_has_boxid();
}
inline const ::std::string& ExtendedSigner::boxid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner.BoxId)
  return *boxid_;
}
inline void ExtendedSigner::set_boxid(const ::std::string& value) {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    boxid_ = new ::std::string;
  }
  boxid_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner.BoxId)
}
inline void ExtendedSigner::set_boxid(const char* value) {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    boxid_ = new ::std::string;
  }
  boxid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner.BoxId)
}
inline void ExtendedSigner::set_boxid(const char* value, size_t size) {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    boxid_ = new ::std::string;
  }
  boxid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner.BoxId)
}
inline ::std::string* ExtendedSigner::mutable_boxid() {
  set_has_boxid();
  if (boxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    boxid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner.BoxId)
  return boxid_;
}
inline ::std::string* ExtendedSigner::release_boxid() {
  clear_has_boxid();
  if (boxid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = boxid_;
    boxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedSigner::set_allocated_boxid(::std::string* boxid) {
  if (boxid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete boxid_;
  }
  if (boxid) {
    set_has_boxid();
    boxid_ = boxid;
  } else {
    clear_has_boxid();
    boxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner.BoxId)
}

// optional bytes SignerCertificate = 2;
inline bool ExtendedSigner::has_signercertificate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtendedSigner::set_has_signercertificate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExtendedSigner::clear_has_signercertificate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExtendedSigner::clear_signercertificate() {
  if (signercertificate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signercertificate_->clear();
  }
  clear_has_signercertificate();
}
inline const ::std::string& ExtendedSigner::signercertificate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner.SignerCertificate)
  return *signercertificate_;
}
inline void ExtendedSigner::set_signercertificate(const ::std::string& value) {
  set_has_signercertificate();
  if (signercertificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signercertificate_ = new ::std::string;
  }
  signercertificate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner.SignerCertificate)
}
inline void ExtendedSigner::set_signercertificate(const char* value) {
  set_has_signercertificate();
  if (signercertificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signercertificate_ = new ::std::string;
  }
  signercertificate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner.SignerCertificate)
}
inline void ExtendedSigner::set_signercertificate(const void* value, size_t size) {
  set_has_signercertificate();
  if (signercertificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signercertificate_ = new ::std::string;
  }
  signercertificate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner.SignerCertificate)
}
inline ::std::string* ExtendedSigner::mutable_signercertificate() {
  set_has_signercertificate();
  if (signercertificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signercertificate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner.SignerCertificate)
  return signercertificate_;
}
inline ::std::string* ExtendedSigner::release_signercertificate() {
  clear_has_signercertificate();
  if (signercertificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signercertificate_;
    signercertificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedSigner::set_allocated_signercertificate(::std::string* signercertificate) {
  if (signercertificate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signercertificate_;
  }
  if (signercertificate) {
    set_has_signercertificate();
    signercertificate_ = signercertificate;
  } else {
    clear_has_signercertificate();
    signercertificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner.SignerCertificate)
}

// optional string SignerCertificateThumbprint = 3;
inline bool ExtendedSigner::has_signercertificatethumbprint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExtendedSigner::set_has_signercertificatethumbprint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExtendedSigner::clear_has_signercertificatethumbprint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExtendedSigner::clear_signercertificatethumbprint() {
  if (signercertificatethumbprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signercertificatethumbprint_->clear();
  }
  clear_has_signercertificatethumbprint();
}
inline const ::std::string& ExtendedSigner::signercertificatethumbprint() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner.SignerCertificateThumbprint)
  return *signercertificatethumbprint_;
}
inline void ExtendedSigner::set_signercertificatethumbprint(const ::std::string& value) {
  set_has_signercertificatethumbprint();
  if (signercertificatethumbprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signercertificatethumbprint_ = new ::std::string;
  }
  signercertificatethumbprint_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner.SignerCertificateThumbprint)
}
inline void ExtendedSigner::set_signercertificatethumbprint(const char* value) {
  set_has_signercertificatethumbprint();
  if (signercertificatethumbprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signercertificatethumbprint_ = new ::std::string;
  }
  signercertificatethumbprint_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner.SignerCertificateThumbprint)
}
inline void ExtendedSigner::set_signercertificatethumbprint(const char* value, size_t size) {
  set_has_signercertificatethumbprint();
  if (signercertificatethumbprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signercertificatethumbprint_ = new ::std::string;
  }
  signercertificatethumbprint_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner.SignerCertificateThumbprint)
}
inline ::std::string* ExtendedSigner::mutable_signercertificatethumbprint() {
  set_has_signercertificatethumbprint();
  if (signercertificatethumbprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signercertificatethumbprint_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner.SignerCertificateThumbprint)
  return signercertificatethumbprint_;
}
inline ::std::string* ExtendedSigner::release_signercertificatethumbprint() {
  clear_has_signercertificatethumbprint();
  if (signercertificatethumbprint_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signercertificatethumbprint_;
    signercertificatethumbprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedSigner::set_allocated_signercertificatethumbprint(::std::string* signercertificatethumbprint) {
  if (signercertificatethumbprint_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signercertificatethumbprint_;
  }
  if (signercertificatethumbprint) {
    set_has_signercertificatethumbprint();
    signercertificatethumbprint_ = signercertificatethumbprint;
  } else {
    clear_has_signercertificatethumbprint();
    signercertificatethumbprint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner.SignerCertificateThumbprint)
}

// optional .Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails SignerDetails = 4;
inline bool ExtendedSigner::has_signerdetails() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExtendedSigner::set_has_signerdetails() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExtendedSigner::clear_has_signerdetails() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExtendedSigner::clear_signerdetails() {
  if (signerdetails_ != NULL) signerdetails_->::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSignerDetails::Clear();
  clear_has_signerdetails();
}
inline const ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSignerDetails& ExtendedSigner::signerdetails() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner.SignerDetails)
  return signerdetails_ != NULL ? *signerdetails_ : *default_instance_->signerdetails_;
}
inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSignerDetails* ExtendedSigner::mutable_signerdetails() {
  set_has_signerdetails();
  if (signerdetails_ == NULL) signerdetails_ = new ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSignerDetails;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner.SignerDetails)
  return signerdetails_;
}
inline ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSignerDetails* ExtendedSigner::release_signerdetails() {
  clear_has_signerdetails();
  ::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSignerDetails* temp = signerdetails_;
  signerdetails_ = NULL;
  return temp;
}
inline void ExtendedSigner::set_allocated_signerdetails(::Diadoc::Api::Proto::Invoicing::Signers::ExtendedSignerDetails* signerdetails) {
  delete signerdetails_;
  signerdetails_ = signerdetails;
  if (signerdetails) {
    set_has_signerdetails();
  } else {
    clear_has_signerdetails();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSigner.SignerDetails)
}

// -------------------------------------------------------------------

// ExtendedSignerDetails

// required string Surname = 1;
inline bool ExtendedSignerDetails::has_surname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtendedSignerDetails::set_has_surname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtendedSignerDetails::clear_has_surname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtendedSignerDetails::clear_surname() {
  if (surname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    surname_->clear();
  }
  clear_has_surname();
}
inline const ::std::string& ExtendedSignerDetails::surname() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.Surname)
  return *surname_;
}
inline void ExtendedSignerDetails::set_surname(const ::std::string& value) {
  set_has_surname();
  if (surname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    surname_ = new ::std::string;
  }
  surname_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.Surname)
}
inline void ExtendedSignerDetails::set_surname(const char* value) {
  set_has_surname();
  if (surname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    surname_ = new ::std::string;
  }
  surname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.Surname)
}
inline void ExtendedSignerDetails::set_surname(const char* value, size_t size) {
  set_has_surname();
  if (surname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    surname_ = new ::std::string;
  }
  surname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.Surname)
}
inline ::std::string* ExtendedSignerDetails::mutable_surname() {
  set_has_surname();
  if (surname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    surname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.Surname)
  return surname_;
}
inline ::std::string* ExtendedSignerDetails::release_surname() {
  clear_has_surname();
  if (surname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = surname_;
    surname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedSignerDetails::set_allocated_surname(::std::string* surname) {
  if (surname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete surname_;
  }
  if (surname) {
    set_has_surname();
    surname_ = surname;
  } else {
    clear_has_surname();
    surname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.Surname)
}

// required string FirstName = 2;
inline bool ExtendedSignerDetails::has_firstname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtendedSignerDetails::set_has_firstname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExtendedSignerDetails::clear_has_firstname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExtendedSignerDetails::clear_firstname() {
  if (firstname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_->clear();
  }
  clear_has_firstname();
}
inline const ::std::string& ExtendedSignerDetails::firstname() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.FirstName)
  return *firstname_;
}
inline void ExtendedSignerDetails::set_firstname(const ::std::string& value) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.FirstName)
}
inline void ExtendedSignerDetails::set_firstname(const char* value) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.FirstName)
}
inline void ExtendedSignerDetails::set_firstname(const char* value, size_t size) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.FirstName)
}
inline ::std::string* ExtendedSignerDetails::mutable_firstname() {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.FirstName)
  return firstname_;
}
inline ::std::string* ExtendedSignerDetails::release_firstname() {
  clear_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = firstname_;
    firstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedSignerDetails::set_allocated_firstname(::std::string* firstname) {
  if (firstname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete firstname_;
  }
  if (firstname) {
    set_has_firstname();
    firstname_ = firstname;
  } else {
    clear_has_firstname();
    firstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.FirstName)
}

// optional string Patronymic = 3;
inline bool ExtendedSignerDetails::has_patronymic() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExtendedSignerDetails::set_has_patronymic() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExtendedSignerDetails::clear_has_patronymic() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExtendedSignerDetails::clear_patronymic() {
  if (patronymic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patronymic_->clear();
  }
  clear_has_patronymic();
}
inline const ::std::string& ExtendedSignerDetails::patronymic() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.Patronymic)
  return *patronymic_;
}
inline void ExtendedSignerDetails::set_patronymic(const ::std::string& value) {
  set_has_patronymic();
  if (patronymic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patronymic_ = new ::std::string;
  }
  patronymic_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.Patronymic)
}
inline void ExtendedSignerDetails::set_patronymic(const char* value) {
  set_has_patronymic();
  if (patronymic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patronymic_ = new ::std::string;
  }
  patronymic_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.Patronymic)
}
inline void ExtendedSignerDetails::set_patronymic(const char* value, size_t size) {
  set_has_patronymic();
  if (patronymic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patronymic_ = new ::std::string;
  }
  patronymic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.Patronymic)
}
inline ::std::string* ExtendedSignerDetails::mutable_patronymic() {
  set_has_patronymic();
  if (patronymic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patronymic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.Patronymic)
  return patronymic_;
}
inline ::std::string* ExtendedSignerDetails::release_patronymic() {
  clear_has_patronymic();
  if (patronymic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = patronymic_;
    patronymic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedSignerDetails::set_allocated_patronymic(::std::string* patronymic) {
  if (patronymic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete patronymic_;
  }
  if (patronymic) {
    set_has_patronymic();
    patronymic_ = patronymic;
  } else {
    clear_has_patronymic();
    patronymic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.Patronymic)
}

// optional string JobTitle = 4;
inline bool ExtendedSignerDetails::has_jobtitle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExtendedSignerDetails::set_has_jobtitle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExtendedSignerDetails::clear_has_jobtitle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExtendedSignerDetails::clear_jobtitle() {
  if (jobtitle_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jobtitle_->clear();
  }
  clear_has_jobtitle();
}
inline const ::std::string& ExtendedSignerDetails::jobtitle() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.JobTitle)
  return *jobtitle_;
}
inline void ExtendedSignerDetails::set_jobtitle(const ::std::string& value) {
  set_has_jobtitle();
  if (jobtitle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jobtitle_ = new ::std::string;
  }
  jobtitle_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.JobTitle)
}
inline void ExtendedSignerDetails::set_jobtitle(const char* value) {
  set_has_jobtitle();
  if (jobtitle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jobtitle_ = new ::std::string;
  }
  jobtitle_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.JobTitle)
}
inline void ExtendedSignerDetails::set_jobtitle(const char* value, size_t size) {
  set_has_jobtitle();
  if (jobtitle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jobtitle_ = new ::std::string;
  }
  jobtitle_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.JobTitle)
}
inline ::std::string* ExtendedSignerDetails::mutable_jobtitle() {
  set_has_jobtitle();
  if (jobtitle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jobtitle_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.JobTitle)
  return jobtitle_;
}
inline ::std::string* ExtendedSignerDetails::release_jobtitle() {
  clear_has_jobtitle();
  if (jobtitle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = jobtitle_;
    jobtitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedSignerDetails::set_allocated_jobtitle(::std::string* jobtitle) {
  if (jobtitle_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete jobtitle_;
  }
  if (jobtitle) {
    set_has_jobtitle();
    jobtitle_ = jobtitle;
  } else {
    clear_has_jobtitle();
    jobtitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.JobTitle)
}

// optional string Inn = 5;
inline bool ExtendedSignerDetails::has_inn() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExtendedSignerDetails::set_has_inn() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExtendedSignerDetails::clear_has_inn() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExtendedSignerDetails::clear_inn() {
  if (inn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inn_->clear();
  }
  clear_has_inn();
}
inline const ::std::string& ExtendedSignerDetails::inn() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.Inn)
  return *inn_;
}
inline void ExtendedSignerDetails::set_inn(const ::std::string& value) {
  set_has_inn();
  if (inn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inn_ = new ::std::string;
  }
  inn_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.Inn)
}
inline void ExtendedSignerDetails::set_inn(const char* value) {
  set_has_inn();
  if (inn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inn_ = new ::std::string;
  }
  inn_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.Inn)
}
inline void ExtendedSignerDetails::set_inn(const char* value, size_t size) {
  set_has_inn();
  if (inn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inn_ = new ::std::string;
  }
  inn_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.Inn)
}
inline ::std::string* ExtendedSignerDetails::mutable_inn() {
  set_has_inn();
  if (inn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inn_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.Inn)
  return inn_;
}
inline ::std::string* ExtendedSignerDetails::release_inn() {
  clear_has_inn();
  if (inn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = inn_;
    inn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedSignerDetails::set_allocated_inn(::std::string* inn) {
  if (inn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete inn_;
  }
  if (inn) {
    set_has_inn();
    inn_ = inn;
  } else {
    clear_has_inn();
    inn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.Inn)
}

// optional string RegistrationCertificate = 6;
inline bool ExtendedSignerDetails::has_registrationcertificate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExtendedSignerDetails::set_has_registrationcertificate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExtendedSignerDetails::clear_has_registrationcertificate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExtendedSignerDetails::clear_registrationcertificate() {
  if (registrationcertificate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    registrationcertificate_->clear();
  }
  clear_has_registrationcertificate();
}
inline const ::std::string& ExtendedSignerDetails::registrationcertificate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.RegistrationCertificate)
  return *registrationcertificate_;
}
inline void ExtendedSignerDetails::set_registrationcertificate(const ::std::string& value) {
  set_has_registrationcertificate();
  if (registrationcertificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    registrationcertificate_ = new ::std::string;
  }
  registrationcertificate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.RegistrationCertificate)
}
inline void ExtendedSignerDetails::set_registrationcertificate(const char* value) {
  set_has_registrationcertificate();
  if (registrationcertificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    registrationcertificate_ = new ::std::string;
  }
  registrationcertificate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.RegistrationCertificate)
}
inline void ExtendedSignerDetails::set_registrationcertificate(const char* value, size_t size) {
  set_has_registrationcertificate();
  if (registrationcertificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    registrationcertificate_ = new ::std::string;
  }
  registrationcertificate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.RegistrationCertificate)
}
inline ::std::string* ExtendedSignerDetails::mutable_registrationcertificate() {
  set_has_registrationcertificate();
  if (registrationcertificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    registrationcertificate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.RegistrationCertificate)
  return registrationcertificate_;
}
inline ::std::string* ExtendedSignerDetails::release_registrationcertificate() {
  clear_has_registrationcertificate();
  if (registrationcertificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = registrationcertificate_;
    registrationcertificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedSignerDetails::set_allocated_registrationcertificate(::std::string* registrationcertificate) {
  if (registrationcertificate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete registrationcertificate_;
  }
  if (registrationcertificate) {
    set_has_registrationcertificate();
    registrationcertificate_ = registrationcertificate;
  } else {
    clear_has_registrationcertificate();
    registrationcertificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.RegistrationCertificate)
}

// required .Diadoc.Api.Proto.Invoicing.Signers.SignerType SignerType = 7 [default = LegalEntity];
inline bool ExtendedSignerDetails::has_signertype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExtendedSignerDetails::set_has_signertype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExtendedSignerDetails::clear_has_signertype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExtendedSignerDetails::clear_signertype() {
  signertype_ = 1;
  clear_has_signertype();
}
inline ::Diadoc::Api::Proto::Invoicing::Signers::SignerType ExtendedSignerDetails::signertype() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerType)
  return static_cast< ::Diadoc::Api::Proto::Invoicing::Signers::SignerType >(signertype_);
}
inline void ExtendedSignerDetails::set_signertype(::Diadoc::Api::Proto::Invoicing::Signers::SignerType value) {
  assert(::Diadoc::Api::Proto::Invoicing::Signers::SignerType_IsValid(value));
  set_has_signertype();
  signertype_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerType)
}

// optional string SignerOrganizationName = 8;
inline bool ExtendedSignerDetails::has_signerorganizationname() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ExtendedSignerDetails::set_has_signerorganizationname() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ExtendedSignerDetails::clear_has_signerorganizationname() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ExtendedSignerDetails::clear_signerorganizationname() {
  if (signerorganizationname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerorganizationname_->clear();
  }
  clear_has_signerorganizationname();
}
inline const ::std::string& ExtendedSignerDetails::signerorganizationname() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerOrganizationName)
  return *signerorganizationname_;
}
inline void ExtendedSignerDetails::set_signerorganizationname(const ::std::string& value) {
  set_has_signerorganizationname();
  if (signerorganizationname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerorganizationname_ = new ::std::string;
  }
  signerorganizationname_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerOrganizationName)
}
inline void ExtendedSignerDetails::set_signerorganizationname(const char* value) {
  set_has_signerorganizationname();
  if (signerorganizationname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerorganizationname_ = new ::std::string;
  }
  signerorganizationname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerOrganizationName)
}
inline void ExtendedSignerDetails::set_signerorganizationname(const char* value, size_t size) {
  set_has_signerorganizationname();
  if (signerorganizationname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerorganizationname_ = new ::std::string;
  }
  signerorganizationname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerOrganizationName)
}
inline ::std::string* ExtendedSignerDetails::mutable_signerorganizationname() {
  set_has_signerorganizationname();
  if (signerorganizationname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerorganizationname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerOrganizationName)
  return signerorganizationname_;
}
inline ::std::string* ExtendedSignerDetails::release_signerorganizationname() {
  clear_has_signerorganizationname();
  if (signerorganizationname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signerorganizationname_;
    signerorganizationname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedSignerDetails::set_allocated_signerorganizationname(::std::string* signerorganizationname) {
  if (signerorganizationname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signerorganizationname_;
  }
  if (signerorganizationname) {
    set_has_signerorganizationname();
    signerorganizationname_ = signerorganizationname;
  } else {
    clear_has_signerorganizationname();
    signerorganizationname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerOrganizationName)
}

// optional string SignerInfo = 9;
inline bool ExtendedSignerDetails::has_signerinfo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ExtendedSignerDetails::set_has_signerinfo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ExtendedSignerDetails::clear_has_signerinfo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ExtendedSignerDetails::clear_signerinfo() {
  if (signerinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerinfo_->clear();
  }
  clear_has_signerinfo();
}
inline const ::std::string& ExtendedSignerDetails::signerinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerInfo)
  return *signerinfo_;
}
inline void ExtendedSignerDetails::set_signerinfo(const ::std::string& value) {
  set_has_signerinfo();
  if (signerinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerinfo_ = new ::std::string;
  }
  signerinfo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerInfo)
}
inline void ExtendedSignerDetails::set_signerinfo(const char* value) {
  set_has_signerinfo();
  if (signerinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerinfo_ = new ::std::string;
  }
  signerinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerInfo)
}
inline void ExtendedSignerDetails::set_signerinfo(const char* value, size_t size) {
  set_has_signerinfo();
  if (signerinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerinfo_ = new ::std::string;
  }
  signerinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerInfo)
}
inline ::std::string* ExtendedSignerDetails::mutable_signerinfo() {
  set_has_signerinfo();
  if (signerinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerInfo)
  return signerinfo_;
}
inline ::std::string* ExtendedSignerDetails::release_signerinfo() {
  clear_has_signerinfo();
  if (signerinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signerinfo_;
    signerinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedSignerDetails::set_allocated_signerinfo(::std::string* signerinfo) {
  if (signerinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signerinfo_;
  }
  if (signerinfo) {
    set_has_signerinfo();
    signerinfo_ = signerinfo;
  } else {
    clear_has_signerinfo();
    signerinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerInfo)
}

// required .Diadoc.Api.Proto.Invoicing.Signers.SignerPowers SignerPowers = 10;
inline bool ExtendedSignerDetails::has_signerpowers() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ExtendedSignerDetails::set_has_signerpowers() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ExtendedSignerDetails::clear_has_signerpowers() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ExtendedSignerDetails::clear_signerpowers() {
  signerpowers_ = 0;
  clear_has_signerpowers();
}
inline ::Diadoc::Api::Proto::Invoicing::Signers::SignerPowers ExtendedSignerDetails::signerpowers() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerPowers)
  return static_cast< ::Diadoc::Api::Proto::Invoicing::Signers::SignerPowers >(signerpowers_);
}
inline void ExtendedSignerDetails::set_signerpowers(::Diadoc::Api::Proto::Invoicing::Signers::SignerPowers value) {
  assert(::Diadoc::Api::Proto::Invoicing::Signers::SignerPowers_IsValid(value));
  set_has_signerpowers();
  signerpowers_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerPowers)
}

// required .Diadoc.Api.Proto.Invoicing.Signers.SignerStatus SignerStatus = 11;
inline bool ExtendedSignerDetails::has_signerstatus() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ExtendedSignerDetails::set_has_signerstatus() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ExtendedSignerDetails::clear_has_signerstatus() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ExtendedSignerDetails::clear_signerstatus() {
  signerstatus_ = 1;
  clear_has_signerstatus();
}
inline ::Diadoc::Api::Proto::Invoicing::Signers::SignerStatus ExtendedSignerDetails::signerstatus() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerStatus)
  return static_cast< ::Diadoc::Api::Proto::Invoicing::Signers::SignerStatus >(signerstatus_);
}
inline void ExtendedSignerDetails::set_signerstatus(::Diadoc::Api::Proto::Invoicing::Signers::SignerStatus value) {
  assert(::Diadoc::Api::Proto::Invoicing::Signers::SignerStatus_IsValid(value));
  set_has_signerstatus();
  signerstatus_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerStatus)
}

// optional string SignerPowersBase = 12;
inline bool ExtendedSignerDetails::has_signerpowersbase() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ExtendedSignerDetails::set_has_signerpowersbase() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ExtendedSignerDetails::clear_has_signerpowersbase() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ExtendedSignerDetails::clear_signerpowersbase() {
  if (signerpowersbase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerpowersbase_->clear();
  }
  clear_has_signerpowersbase();
}
inline const ::std::string& ExtendedSignerDetails::signerpowersbase() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerPowersBase)
  return *signerpowersbase_;
}
inline void ExtendedSignerDetails::set_signerpowersbase(const ::std::string& value) {
  set_has_signerpowersbase();
  if (signerpowersbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerpowersbase_ = new ::std::string;
  }
  signerpowersbase_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerPowersBase)
}
inline void ExtendedSignerDetails::set_signerpowersbase(const char* value) {
  set_has_signerpowersbase();
  if (signerpowersbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerpowersbase_ = new ::std::string;
  }
  signerpowersbase_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerPowersBase)
}
inline void ExtendedSignerDetails::set_signerpowersbase(const char* value, size_t size) {
  set_has_signerpowersbase();
  if (signerpowersbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerpowersbase_ = new ::std::string;
  }
  signerpowersbase_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerPowersBase)
}
inline ::std::string* ExtendedSignerDetails::mutable_signerpowersbase() {
  set_has_signerpowersbase();
  if (signerpowersbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerpowersbase_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerPowersBase)
  return signerpowersbase_;
}
inline ::std::string* ExtendedSignerDetails::release_signerpowersbase() {
  clear_has_signerpowersbase();
  if (signerpowersbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signerpowersbase_;
    signerpowersbase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedSignerDetails::set_allocated_signerpowersbase(::std::string* signerpowersbase) {
  if (signerpowersbase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signerpowersbase_;
  }
  if (signerpowersbase) {
    set_has_signerpowersbase();
    signerpowersbase_ = signerpowersbase;
  } else {
    clear_has_signerpowersbase();
    signerpowersbase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerPowersBase)
}

// optional string SignerOrgPowersBase = 13;
inline bool ExtendedSignerDetails::has_signerorgpowersbase() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ExtendedSignerDetails::set_has_signerorgpowersbase() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ExtendedSignerDetails::clear_has_signerorgpowersbase() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ExtendedSignerDetails::clear_signerorgpowersbase() {
  if (signerorgpowersbase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerorgpowersbase_->clear();
  }
  clear_has_signerorgpowersbase();
}
inline const ::std::string& ExtendedSignerDetails::signerorgpowersbase() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerOrgPowersBase)
  return *signerorgpowersbase_;
}
inline void ExtendedSignerDetails::set_signerorgpowersbase(const ::std::string& value) {
  set_has_signerorgpowersbase();
  if (signerorgpowersbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerorgpowersbase_ = new ::std::string;
  }
  signerorgpowersbase_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerOrgPowersBase)
}
inline void ExtendedSignerDetails::set_signerorgpowersbase(const char* value) {
  set_has_signerorgpowersbase();
  if (signerorgpowersbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerorgpowersbase_ = new ::std::string;
  }
  signerorgpowersbase_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerOrgPowersBase)
}
inline void ExtendedSignerDetails::set_signerorgpowersbase(const char* value, size_t size) {
  set_has_signerorgpowersbase();
  if (signerorgpowersbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerorgpowersbase_ = new ::std::string;
  }
  signerorgpowersbase_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerOrgPowersBase)
}
inline ::std::string* ExtendedSignerDetails::mutable_signerorgpowersbase() {
  set_has_signerorgpowersbase();
  if (signerorgpowersbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerorgpowersbase_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerOrgPowersBase)
  return signerorgpowersbase_;
}
inline ::std::string* ExtendedSignerDetails::release_signerorgpowersbase() {
  clear_has_signerorgpowersbase();
  if (signerorgpowersbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signerorgpowersbase_;
    signerorgpowersbase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedSignerDetails::set_allocated_signerorgpowersbase(::std::string* signerorgpowersbase) {
  if (signerorgpowersbase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signerorgpowersbase_;
  }
  if (signerorgpowersbase) {
    set_has_signerorgpowersbase();
    signerorgpowersbase_ = signerorgpowersbase;
  } else {
    clear_has_signerorgpowersbase();
    signerorgpowersbase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetails.SignerOrgPowersBase)
}

// -------------------------------------------------------------------

// ExtendedSignerDetailsToPost

// optional string JobTitle = 1;
inline bool ExtendedSignerDetailsToPost::has_jobtitle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtendedSignerDetailsToPost::set_has_jobtitle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtendedSignerDetailsToPost::clear_has_jobtitle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtendedSignerDetailsToPost::clear_jobtitle() {
  if (jobtitle_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jobtitle_->clear();
  }
  clear_has_jobtitle();
}
inline const ::std::string& ExtendedSignerDetailsToPost::jobtitle() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.JobTitle)
  return *jobtitle_;
}
inline void ExtendedSignerDetailsToPost::set_jobtitle(const ::std::string& value) {
  set_has_jobtitle();
  if (jobtitle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jobtitle_ = new ::std::string;
  }
  jobtitle_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.JobTitle)
}
inline void ExtendedSignerDetailsToPost::set_jobtitle(const char* value) {
  set_has_jobtitle();
  if (jobtitle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jobtitle_ = new ::std::string;
  }
  jobtitle_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.JobTitle)
}
inline void ExtendedSignerDetailsToPost::set_jobtitle(const char* value, size_t size) {
  set_has_jobtitle();
  if (jobtitle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jobtitle_ = new ::std::string;
  }
  jobtitle_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.JobTitle)
}
inline ::std::string* ExtendedSignerDetailsToPost::mutable_jobtitle() {
  set_has_jobtitle();
  if (jobtitle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jobtitle_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.JobTitle)
  return jobtitle_;
}
inline ::std::string* ExtendedSignerDetailsToPost::release_jobtitle() {
  clear_has_jobtitle();
  if (jobtitle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = jobtitle_;
    jobtitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedSignerDetailsToPost::set_allocated_jobtitle(::std::string* jobtitle) {
  if (jobtitle_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete jobtitle_;
  }
  if (jobtitle) {
    set_has_jobtitle();
    jobtitle_ = jobtitle;
  } else {
    clear_has_jobtitle();
    jobtitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.JobTitle)
}

// optional string RegistrationCertificate = 2;
inline bool ExtendedSignerDetailsToPost::has_registrationcertificate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtendedSignerDetailsToPost::set_has_registrationcertificate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExtendedSignerDetailsToPost::clear_has_registrationcertificate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExtendedSignerDetailsToPost::clear_registrationcertificate() {
  if (registrationcertificate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    registrationcertificate_->clear();
  }
  clear_has_registrationcertificate();
}
inline const ::std::string& ExtendedSignerDetailsToPost::registrationcertificate() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.RegistrationCertificate)
  return *registrationcertificate_;
}
inline void ExtendedSignerDetailsToPost::set_registrationcertificate(const ::std::string& value) {
  set_has_registrationcertificate();
  if (registrationcertificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    registrationcertificate_ = new ::std::string;
  }
  registrationcertificate_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.RegistrationCertificate)
}
inline void ExtendedSignerDetailsToPost::set_registrationcertificate(const char* value) {
  set_has_registrationcertificate();
  if (registrationcertificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    registrationcertificate_ = new ::std::string;
  }
  registrationcertificate_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.RegistrationCertificate)
}
inline void ExtendedSignerDetailsToPost::set_registrationcertificate(const char* value, size_t size) {
  set_has_registrationcertificate();
  if (registrationcertificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    registrationcertificate_ = new ::std::string;
  }
  registrationcertificate_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.RegistrationCertificate)
}
inline ::std::string* ExtendedSignerDetailsToPost::mutable_registrationcertificate() {
  set_has_registrationcertificate();
  if (registrationcertificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    registrationcertificate_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.RegistrationCertificate)
  return registrationcertificate_;
}
inline ::std::string* ExtendedSignerDetailsToPost::release_registrationcertificate() {
  clear_has_registrationcertificate();
  if (registrationcertificate_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = registrationcertificate_;
    registrationcertificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedSignerDetailsToPost::set_allocated_registrationcertificate(::std::string* registrationcertificate) {
  if (registrationcertificate_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete registrationcertificate_;
  }
  if (registrationcertificate) {
    set_has_registrationcertificate();
    registrationcertificate_ = registrationcertificate;
  } else {
    clear_has_registrationcertificate();
    registrationcertificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.RegistrationCertificate)
}

// required .Diadoc.Api.Proto.Invoicing.Signers.SignerType SignerType = 3;
inline bool ExtendedSignerDetailsToPost::has_signertype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExtendedSignerDetailsToPost::set_has_signertype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExtendedSignerDetailsToPost::clear_has_signertype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExtendedSignerDetailsToPost::clear_signertype() {
  signertype_ = 1;
  clear_has_signertype();
}
inline ::Diadoc::Api::Proto::Invoicing::Signers::SignerType ExtendedSignerDetailsToPost::signertype() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerType)
  return static_cast< ::Diadoc::Api::Proto::Invoicing::Signers::SignerType >(signertype_);
}
inline void ExtendedSignerDetailsToPost::set_signertype(::Diadoc::Api::Proto::Invoicing::Signers::SignerType value) {
  assert(::Diadoc::Api::Proto::Invoicing::Signers::SignerType_IsValid(value));
  set_has_signertype();
  signertype_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerType)
}

// optional string SignerInfo = 4;
inline bool ExtendedSignerDetailsToPost::has_signerinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExtendedSignerDetailsToPost::set_has_signerinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExtendedSignerDetailsToPost::clear_has_signerinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExtendedSignerDetailsToPost::clear_signerinfo() {
  if (signerinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerinfo_->clear();
  }
  clear_has_signerinfo();
}
inline const ::std::string& ExtendedSignerDetailsToPost::signerinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerInfo)
  return *signerinfo_;
}
inline void ExtendedSignerDetailsToPost::set_signerinfo(const ::std::string& value) {
  set_has_signerinfo();
  if (signerinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerinfo_ = new ::std::string;
  }
  signerinfo_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerInfo)
}
inline void ExtendedSignerDetailsToPost::set_signerinfo(const char* value) {
  set_has_signerinfo();
  if (signerinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerinfo_ = new ::std::string;
  }
  signerinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerInfo)
}
inline void ExtendedSignerDetailsToPost::set_signerinfo(const char* value, size_t size) {
  set_has_signerinfo();
  if (signerinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerinfo_ = new ::std::string;
  }
  signerinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerInfo)
}
inline ::std::string* ExtendedSignerDetailsToPost::mutable_signerinfo() {
  set_has_signerinfo();
  if (signerinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerInfo)
  return signerinfo_;
}
inline ::std::string* ExtendedSignerDetailsToPost::release_signerinfo() {
  clear_has_signerinfo();
  if (signerinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signerinfo_;
    signerinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedSignerDetailsToPost::set_allocated_signerinfo(::std::string* signerinfo) {
  if (signerinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signerinfo_;
  }
  if (signerinfo) {
    set_has_signerinfo();
    signerinfo_ = signerinfo;
  } else {
    clear_has_signerinfo();
    signerinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerInfo)
}

// required .Diadoc.Api.Proto.Invoicing.Signers.SignerPowers SignerPowers = 5;
inline bool ExtendedSignerDetailsToPost::has_signerpowers() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExtendedSignerDetailsToPost::set_has_signerpowers() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExtendedSignerDetailsToPost::clear_has_signerpowers() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExtendedSignerDetailsToPost::clear_signerpowers() {
  signerpowers_ = 0;
  clear_has_signerpowers();
}
inline ::Diadoc::Api::Proto::Invoicing::Signers::SignerPowers ExtendedSignerDetailsToPost::signerpowers() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerPowers)
  return static_cast< ::Diadoc::Api::Proto::Invoicing::Signers::SignerPowers >(signerpowers_);
}
inline void ExtendedSignerDetailsToPost::set_signerpowers(::Diadoc::Api::Proto::Invoicing::Signers::SignerPowers value) {
  assert(::Diadoc::Api::Proto::Invoicing::Signers::SignerPowers_IsValid(value));
  set_has_signerpowers();
  signerpowers_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerPowers)
}

// required .Diadoc.Api.Proto.Invoicing.Signers.SignerStatus SignerStatus = 6;
inline bool ExtendedSignerDetailsToPost::has_signerstatus() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExtendedSignerDetailsToPost::set_has_signerstatus() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExtendedSignerDetailsToPost::clear_has_signerstatus() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExtendedSignerDetailsToPost::clear_signerstatus() {
  signerstatus_ = 1;
  clear_has_signerstatus();
}
inline ::Diadoc::Api::Proto::Invoicing::Signers::SignerStatus ExtendedSignerDetailsToPost::signerstatus() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerStatus)
  return static_cast< ::Diadoc::Api::Proto::Invoicing::Signers::SignerStatus >(signerstatus_);
}
inline void ExtendedSignerDetailsToPost::set_signerstatus(::Diadoc::Api::Proto::Invoicing::Signers::SignerStatus value) {
  assert(::Diadoc::Api::Proto::Invoicing::Signers::SignerStatus_IsValid(value));
  set_has_signerstatus();
  signerstatus_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerStatus)
}

// optional string SignerPowersBase = 7;
inline bool ExtendedSignerDetailsToPost::has_signerpowersbase() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExtendedSignerDetailsToPost::set_has_signerpowersbase() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExtendedSignerDetailsToPost::clear_has_signerpowersbase() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExtendedSignerDetailsToPost::clear_signerpowersbase() {
  if (signerpowersbase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerpowersbase_->clear();
  }
  clear_has_signerpowersbase();
}
inline const ::std::string& ExtendedSignerDetailsToPost::signerpowersbase() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerPowersBase)
  return *signerpowersbase_;
}
inline void ExtendedSignerDetailsToPost::set_signerpowersbase(const ::std::string& value) {
  set_has_signerpowersbase();
  if (signerpowersbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerpowersbase_ = new ::std::string;
  }
  signerpowersbase_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerPowersBase)
}
inline void ExtendedSignerDetailsToPost::set_signerpowersbase(const char* value) {
  set_has_signerpowersbase();
  if (signerpowersbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerpowersbase_ = new ::std::string;
  }
  signerpowersbase_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerPowersBase)
}
inline void ExtendedSignerDetailsToPost::set_signerpowersbase(const char* value, size_t size) {
  set_has_signerpowersbase();
  if (signerpowersbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerpowersbase_ = new ::std::string;
  }
  signerpowersbase_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerPowersBase)
}
inline ::std::string* ExtendedSignerDetailsToPost::mutable_signerpowersbase() {
  set_has_signerpowersbase();
  if (signerpowersbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerpowersbase_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerPowersBase)
  return signerpowersbase_;
}
inline ::std::string* ExtendedSignerDetailsToPost::release_signerpowersbase() {
  clear_has_signerpowersbase();
  if (signerpowersbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signerpowersbase_;
    signerpowersbase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedSignerDetailsToPost::set_allocated_signerpowersbase(::std::string* signerpowersbase) {
  if (signerpowersbase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signerpowersbase_;
  }
  if (signerpowersbase) {
    set_has_signerpowersbase();
    signerpowersbase_ = signerpowersbase;
  } else {
    clear_has_signerpowersbase();
    signerpowersbase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerPowersBase)
}

// optional string SignerOrgPowersBase = 8;
inline bool ExtendedSignerDetailsToPost::has_signerorgpowersbase() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ExtendedSignerDetailsToPost::set_has_signerorgpowersbase() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ExtendedSignerDetailsToPost::clear_has_signerorgpowersbase() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ExtendedSignerDetailsToPost::clear_signerorgpowersbase() {
  if (signerorgpowersbase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerorgpowersbase_->clear();
  }
  clear_has_signerorgpowersbase();
}
inline const ::std::string& ExtendedSignerDetailsToPost::signerorgpowersbase() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerOrgPowersBase)
  return *signerorgpowersbase_;
}
inline void ExtendedSignerDetailsToPost::set_signerorgpowersbase(const ::std::string& value) {
  set_has_signerorgpowersbase();
  if (signerorgpowersbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerorgpowersbase_ = new ::std::string;
  }
  signerorgpowersbase_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerOrgPowersBase)
}
inline void ExtendedSignerDetailsToPost::set_signerorgpowersbase(const char* value) {
  set_has_signerorgpowersbase();
  if (signerorgpowersbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerorgpowersbase_ = new ::std::string;
  }
  signerorgpowersbase_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerOrgPowersBase)
}
inline void ExtendedSignerDetailsToPost::set_signerorgpowersbase(const char* value, size_t size) {
  set_has_signerorgpowersbase();
  if (signerorgpowersbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerorgpowersbase_ = new ::std::string;
  }
  signerorgpowersbase_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerOrgPowersBase)
}
inline ::std::string* ExtendedSignerDetailsToPost::mutable_signerorgpowersbase() {
  set_has_signerorgpowersbase();
  if (signerorgpowersbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signerorgpowersbase_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerOrgPowersBase)
  return signerorgpowersbase_;
}
inline ::std::string* ExtendedSignerDetailsToPost::release_signerorgpowersbase() {
  clear_has_signerorgpowersbase();
  if (signerorgpowersbase_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signerorgpowersbase_;
    signerorgpowersbase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExtendedSignerDetailsToPost::set_allocated_signerorgpowersbase(::std::string* signerorgpowersbase) {
  if (signerorgpowersbase_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signerorgpowersbase_;
  }
  if (signerorgpowersbase) {
    set_has_signerorgpowersbase();
    signerorgpowersbase_ = signerorgpowersbase;
  } else {
    clear_has_signerorgpowersbase();
    signerorgpowersbase_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Invoicing.Signers.ExtendedSignerDetailsToPost.SignerOrgPowersBase)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Signers
}  // namespace Invoicing
}  // namespace Proto
}  // namespace Api
}  // namespace Diadoc

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Diadoc::Api::Proto::Invoicing::Signers::SignerType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Diadoc::Api::Proto::Invoicing::Signers::SignerType>() {
  return ::Diadoc::Api::Proto::Invoicing::Signers::SignerType_descriptor();
}
template <> struct is_proto_enum< ::Diadoc::Api::Proto::Invoicing::Signers::SignerPowers> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Diadoc::Api::Proto::Invoicing::Signers::SignerPowers>() {
  return ::Diadoc::Api::Proto::Invoicing::Signers::SignerPowers_descriptor();
}
template <> struct is_proto_enum< ::Diadoc::Api::Proto::Invoicing::Signers::SignerStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Diadoc::Api::Proto::Invoicing::Signers::SignerStatus>() {
  return ::Diadoc::Api::Proto::Invoicing::Signers::SignerStatus_descriptor();
}
template <> struct is_proto_enum< ::Diadoc::Api::Proto::Invoicing::Signers::DocumentTitleType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Diadoc::Api::Proto::Invoicing::Signers::DocumentTitleType>() {
  return ::Diadoc::Api::Proto::Invoicing::Signers::DocumentTitleType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Invoicing_2fExtendedSigner_2eproto__INCLUDED

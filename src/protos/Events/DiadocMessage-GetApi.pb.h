// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Events/DiadocMessage-GetApi.proto

#ifndef PROTOBUF_Events_2fDiadocMessage_2eGetApi_2eproto__INCLUDED
#define PROTOBUF_Events_2fDiadocMessage_2eGetApi_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "Content.pb.h"
#include "DocumentId.pb.h"
#include "Documents/Document.pb.h"
#include "Events/ResolutionInfo.pb.h"
#include "Events/ResolutionRequestInfo.pb.h"
#include "Events/ResolutionRequestDenialInfo.pb.h"
// @@protoc_insertion_point(includes)

namespace Diadoc {
namespace Api {
namespace Proto {
namespace Events {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Events_2fDiadocMessage_2eGetApi_2eproto();
void protobuf_AssignDesc_Events_2fDiadocMessage_2eGetApi_2eproto();
void protobuf_ShutdownFile_Events_2fDiadocMessage_2eGetApi_2eproto();

class BoxEventList;
class BoxEvent;
class Message;
class MessagePatch;
class Entity;
class EntityPatch;

enum EntityType {
  UnknownEntityType = 0,
  Attachment = 1,
  Signature = 2
};
bool EntityType_IsValid(int value);
const EntityType EntityType_MIN = UnknownEntityType;
const EntityType EntityType_MAX = Signature;
const int EntityType_ARRAYSIZE = EntityType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EntityType_descriptor();
inline const ::std::string& EntityType_Name(EntityType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EntityType_descriptor(), value);
}
inline bool EntityType_Parse(
    const ::std::string& name, EntityType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EntityType>(
    EntityType_descriptor(), name, value);
}
enum AttachmentType {
  UnknownAttachmentType = -1,
  Nonformalized = 0,
  Invoice = 1,
  InvoiceReceipt = 2,
  InvoiceConfirmation = 3,
  InvoiceCorrectionRequest = 4,
  AttachmentComment = 5,
  DeliveryFailureNotification = 6,
  EancomInvoic = 7,
  SignatureRequestRejection = 8,
  EcrCatConformanceCertificateMetadata = 9,
  SignatureVerificationReport = 10,
  TrustConnectionRequest = 11,
  Torg12 = 12,
  InvoiceRevision = 13,
  InvoiceCorrection = 14,
  InvoiceCorrectionRevision = 15,
  AcceptanceCertificate = 16,
  StructuredData = 17,
  ProformaInvoice = 18,
  XmlTorg12 = 19,
  XmlAcceptanceCertificate = 20,
  XmlTorg12BuyerTitle = 21,
  XmlAcceptanceCertificateBuyerTitle = 22,
  Resolution = 23,
  ResolutionRequest = 24,
  ResolutionRequestDenial = 25,
  PriceList = 26,
  Receipt = 27,
  XmlSignatureRejection = 28,
  RevocationRequest = 29,
  PriceListAgreement = 30,
  CertificateRegistry = 34,
  ReconciliationAct = 35,
  Contract = 36,
  Torg13 = 37,
  ServiceDetails = 38,
  RoamingNotification = 39,
  SupplementaryAgreement = 40,
  CustomData = 64
};
bool AttachmentType_IsValid(int value);
const AttachmentType AttachmentType_MIN = UnknownAttachmentType;
const AttachmentType AttachmentType_MAX = CustomData;
const int AttachmentType_ARRAYSIZE = AttachmentType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AttachmentType_descriptor();
inline const ::std::string& AttachmentType_Name(AttachmentType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AttachmentType_descriptor(), value);
}
inline bool AttachmentType_Parse(
    const ::std::string& name, AttachmentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AttachmentType>(
    AttachmentType_descriptor(), name, value);
}
// ===================================================================

class BoxEventList : public ::google::protobuf::Message {
 public:
  BoxEventList();
  virtual ~BoxEventList();
  
  BoxEventList(const BoxEventList& from);
  
  inline BoxEventList& operator=(const BoxEventList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BoxEventList& default_instance();
  
  void Swap(BoxEventList* other);
  
  // implements Message ----------------------------------------------
  
  BoxEventList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoxEventList& from);
  void MergeFrom(const BoxEventList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Diadoc.Api.Proto.Events.BoxEvent Events = 1;
  inline int events_size() const;
  inline void clear_events();
  static const int kEventsFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Events::BoxEvent& events(int index) const;
  inline ::Diadoc::Api::Proto::Events::BoxEvent* mutable_events(int index);
  inline ::Diadoc::Api::Proto::Events::BoxEvent* add_events();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::BoxEvent >&
      events() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::BoxEvent >*
      mutable_events();
  
  // optional int32 TotalCount = 2;
  inline bool has_totalcount() const;
  inline void clear_totalcount();
  static const int kTotalCountFieldNumber = 2;
  inline ::google::protobuf::int32 totalcount() const;
  inline void set_totalcount(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.BoxEventList)
 private:
  inline void set_has_totalcount();
  inline void clear_has_totalcount();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::BoxEvent > events_;
  ::google::protobuf::int32 totalcount_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2eGetApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2eGetApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2eGetApi_2eproto();
  
  void InitAsDefaultInstance();
  static BoxEventList* default_instance_;
};
// -------------------------------------------------------------------

class BoxEvent : public ::google::protobuf::Message {
 public:
  BoxEvent();
  virtual ~BoxEvent();
  
  BoxEvent(const BoxEvent& from);
  
  inline BoxEvent& operator=(const BoxEvent& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BoxEvent& default_instance();
  
  void Swap(BoxEvent* other);
  
  // implements Message ----------------------------------------------
  
  BoxEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoxEvent& from);
  void MergeFrom(const BoxEvent& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string EventId = 1;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventIdFieldNumber = 1;
  inline const ::std::string& eventid() const;
  inline void set_eventid(const ::std::string& value);
  inline void set_eventid(const char* value);
  inline void set_eventid(const char* value, size_t size);
  inline ::std::string* mutable_eventid();
  inline ::std::string* release_eventid();
  
  // optional .Diadoc.Api.Proto.Events.Message Message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Events::Message& message() const;
  inline ::Diadoc::Api::Proto::Events::Message* mutable_message();
  inline ::Diadoc::Api::Proto::Events::Message* release_message();
  
  // optional .Diadoc.Api.Proto.Events.MessagePatch Patch = 3;
  inline bool has_patch() const;
  inline void clear_patch();
  static const int kPatchFieldNumber = 3;
  inline const ::Diadoc::Api::Proto::Events::MessagePatch& patch() const;
  inline ::Diadoc::Api::Proto::Events::MessagePatch* mutable_patch();
  inline ::Diadoc::Api::Proto::Events::MessagePatch* release_patch();
  
  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.BoxEvent)
 private:
  inline void set_has_eventid();
  inline void clear_has_eventid();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_patch();
  inline void clear_has_patch();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* eventid_;
  ::Diadoc::Api::Proto::Events::Message* message_;
  ::Diadoc::Api::Proto::Events::MessagePatch* patch_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2eGetApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2eGetApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2eGetApi_2eproto();
  
  void InitAsDefaultInstance();
  static BoxEvent* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();
  
  Message(const Message& from);
  
  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();
  
  void Swap(Message* other);
  
  // implements Message ----------------------------------------------
  
  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string MessageId = 1;
  inline bool has_messageid() const;
  inline void clear_messageid();
  static const int kMessageIdFieldNumber = 1;
  inline const ::std::string& messageid() const;
  inline void set_messageid(const ::std::string& value);
  inline void set_messageid(const char* value);
  inline void set_messageid(const char* value, size_t size);
  inline ::std::string* mutable_messageid();
  inline ::std::string* release_messageid();
  
  // required sfixed64 TimestampTicks = 2;
  inline bool has_timestampticks() const;
  inline void clear_timestampticks();
  static const int kTimestampTicksFieldNumber = 2;
  inline ::google::protobuf::int64 timestampticks() const;
  inline void set_timestampticks(::google::protobuf::int64 value);
  
  // required sfixed64 LastPatchTimestampTicks = 3;
  inline bool has_lastpatchtimestampticks() const;
  inline void clear_lastpatchtimestampticks();
  static const int kLastPatchTimestampTicksFieldNumber = 3;
  inline ::google::protobuf::int64 lastpatchtimestampticks() const;
  inline void set_lastpatchtimestampticks(::google::protobuf::int64 value);
  
  // required string FromBoxId = 4;
  inline bool has_fromboxid() const;
  inline void clear_fromboxid();
  static const int kFromBoxIdFieldNumber = 4;
  inline const ::std::string& fromboxid() const;
  inline void set_fromboxid(const ::std::string& value);
  inline void set_fromboxid(const char* value);
  inline void set_fromboxid(const char* value, size_t size);
  inline ::std::string* mutable_fromboxid();
  inline ::std::string* release_fromboxid();
  
  // required string FromTitle = 5;
  inline bool has_fromtitle() const;
  inline void clear_fromtitle();
  static const int kFromTitleFieldNumber = 5;
  inline const ::std::string& fromtitle() const;
  inline void set_fromtitle(const ::std::string& value);
  inline void set_fromtitle(const char* value);
  inline void set_fromtitle(const char* value, size_t size);
  inline ::std::string* mutable_fromtitle();
  inline ::std::string* release_fromtitle();
  
  // optional string ToBoxId = 6;
  inline bool has_toboxid() const;
  inline void clear_toboxid();
  static const int kToBoxIdFieldNumber = 6;
  inline const ::std::string& toboxid() const;
  inline void set_toboxid(const ::std::string& value);
  inline void set_toboxid(const char* value);
  inline void set_toboxid(const char* value, size_t size);
  inline ::std::string* mutable_toboxid();
  inline ::std::string* release_toboxid();
  
  // optional string ToTitle = 7;
  inline bool has_totitle() const;
  inline void clear_totitle();
  static const int kToTitleFieldNumber = 7;
  inline const ::std::string& totitle() const;
  inline void set_totitle(const ::std::string& value);
  inline void set_totitle(const char* value);
  inline void set_totitle(const char* value, size_t size);
  inline ::std::string* mutable_totitle();
  inline ::std::string* release_totitle();
  
  // repeated .Diadoc.Api.Proto.Events.Entity Entities = 8;
  inline int entities_size() const;
  inline void clear_entities();
  static const int kEntitiesFieldNumber = 8;
  inline const ::Diadoc::Api::Proto::Events::Entity& entities(int index) const;
  inline ::Diadoc::Api::Proto::Events::Entity* mutable_entities(int index);
  inline ::Diadoc::Api::Proto::Events::Entity* add_entities();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::Entity >&
      entities() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::Entity >*
      mutable_entities();
  
  // optional bool IsDraft = 9 [default = false];
  inline bool has_isdraft() const;
  inline void clear_isdraft();
  static const int kIsDraftFieldNumber = 9;
  inline bool isdraft() const;
  inline void set_isdraft(bool value);
  
  // optional bool DraftIsLocked = 10 [default = false];
  inline bool has_draftislocked() const;
  inline void clear_draftislocked();
  static const int kDraftIsLockedFieldNumber = 10;
  inline bool draftislocked() const;
  inline void set_draftislocked(bool value);
  
  // optional bool DraftIsRecycled = 11 [default = false];
  inline bool has_draftisrecycled() const;
  inline void clear_draftisrecycled();
  static const int kDraftIsRecycledFieldNumber = 11;
  inline bool draftisrecycled() const;
  inline void set_draftisrecycled(bool value);
  
  // optional string CreatedFromDraftId = 12;
  inline bool has_createdfromdraftid() const;
  inline void clear_createdfromdraftid();
  static const int kCreatedFromDraftIdFieldNumber = 12;
  inline const ::std::string& createdfromdraftid() const;
  inline void set_createdfromdraftid(const ::std::string& value);
  inline void set_createdfromdraftid(const char* value);
  inline void set_createdfromdraftid(const char* value, size_t size);
  inline ::std::string* mutable_createdfromdraftid();
  inline ::std::string* release_createdfromdraftid();
  
  // repeated string DraftIsTransformedToMessageIdList = 13;
  inline int draftistransformedtomessageidlist_size() const;
  inline void clear_draftistransformedtomessageidlist();
  static const int kDraftIsTransformedToMessageIdListFieldNumber = 13;
  inline const ::std::string& draftistransformedtomessageidlist(int index) const;
  inline ::std::string* mutable_draftistransformedtomessageidlist(int index);
  inline void set_draftistransformedtomessageidlist(int index, const ::std::string& value);
  inline void set_draftistransformedtomessageidlist(int index, const char* value);
  inline void set_draftistransformedtomessageidlist(int index, const char* value, size_t size);
  inline ::std::string* add_draftistransformedtomessageidlist();
  inline void add_draftistransformedtomessageidlist(const ::std::string& value);
  inline void add_draftistransformedtomessageidlist(const char* value);
  inline void add_draftistransformedtomessageidlist(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& draftistransformedtomessageidlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_draftistransformedtomessageidlist();
  
  // optional bool IsDeleted = 14 [default = false];
  inline bool has_isdeleted() const;
  inline void clear_isdeleted();
  static const int kIsDeletedFieldNumber = 14;
  inline bool isdeleted() const;
  inline void set_isdeleted(bool value);
  
  // optional bool IsTest = 15 [default = false];
  inline bool has_istest() const;
  inline void clear_istest();
  static const int kIsTestFieldNumber = 15;
  inline bool istest() const;
  inline void set_istest(bool value);
  
  // optional bool IsInternal = 16 [default = false];
  inline bool has_isinternal() const;
  inline void clear_isinternal();
  static const int kIsInternalFieldNumber = 16;
  inline bool isinternal() const;
  inline void set_isinternal(bool value);
  
  // optional bool IsProxified = 17 [default = false];
  inline bool has_isproxified() const;
  inline void clear_isproxified();
  static const int kIsProxifiedFieldNumber = 17;
  inline bool isproxified() const;
  inline void set_isproxified(bool value);
  
  // optional string ProxyBoxId = 18;
  inline bool has_proxyboxid() const;
  inline void clear_proxyboxid();
  static const int kProxyBoxIdFieldNumber = 18;
  inline const ::std::string& proxyboxid() const;
  inline void set_proxyboxid(const ::std::string& value);
  inline void set_proxyboxid(const char* value);
  inline void set_proxyboxid(const char* value, size_t size);
  inline ::std::string* mutable_proxyboxid();
  inline ::std::string* release_proxyboxid();
  
  // optional string ProxyTitle = 19;
  inline bool has_proxytitle() const;
  inline void clear_proxytitle();
  static const int kProxyTitleFieldNumber = 19;
  inline const ::std::string& proxytitle() const;
  inline void set_proxytitle(const ::std::string& value);
  inline void set_proxytitle(const char* value);
  inline void set_proxytitle(const char* value, size_t size);
  inline ::std::string* mutable_proxytitle();
  inline ::std::string* release_proxytitle();
  
  // optional bool PacketIsLocked = 20 [default = false];
  inline bool has_packetislocked() const;
  inline void clear_packetislocked();
  static const int kPacketIsLockedFieldNumber = 20;
  inline bool packetislocked() const;
  inline void set_packetislocked(bool value);
  
  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.Message)
 private:
  inline void set_has_messageid();
  inline void clear_has_messageid();
  inline void set_has_timestampticks();
  inline void clear_has_timestampticks();
  inline void set_has_lastpatchtimestampticks();
  inline void clear_has_lastpatchtimestampticks();
  inline void set_has_fromboxid();
  inline void clear_has_fromboxid();
  inline void set_has_fromtitle();
  inline void clear_has_fromtitle();
  inline void set_has_toboxid();
  inline void clear_has_toboxid();
  inline void set_has_totitle();
  inline void clear_has_totitle();
  inline void set_has_isdraft();
  inline void clear_has_isdraft();
  inline void set_has_draftislocked();
  inline void clear_has_draftislocked();
  inline void set_has_draftisrecycled();
  inline void clear_has_draftisrecycled();
  inline void set_has_createdfromdraftid();
  inline void clear_has_createdfromdraftid();
  inline void set_has_isdeleted();
  inline void clear_has_isdeleted();
  inline void set_has_istest();
  inline void clear_has_istest();
  inline void set_has_isinternal();
  inline void clear_has_isinternal();
  inline void set_has_isproxified();
  inline void clear_has_isproxified();
  inline void set_has_proxyboxid();
  inline void clear_has_proxyboxid();
  inline void set_has_proxytitle();
  inline void clear_has_proxytitle();
  inline void set_has_packetislocked();
  inline void clear_has_packetislocked();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* messageid_;
  ::google::protobuf::int64 timestampticks_;
  ::google::protobuf::int64 lastpatchtimestampticks_;
  ::std::string* fromboxid_;
  ::std::string* fromtitle_;
  ::std::string* toboxid_;
  ::std::string* totitle_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::Entity > entities_;
  ::std::string* createdfromdraftid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> draftistransformedtomessageidlist_;
  bool isdraft_;
  bool draftislocked_;
  bool draftisrecycled_;
  bool isdeleted_;
  bool istest_;
  bool isinternal_;
  bool isproxified_;
  bool packetislocked_;
  ::std::string* proxyboxid_;
  ::std::string* proxytitle_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];
  
  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2eGetApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2eGetApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2eGetApi_2eproto();
  
  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class MessagePatch : public ::google::protobuf::Message {
 public:
  MessagePatch();
  virtual ~MessagePatch();
  
  MessagePatch(const MessagePatch& from);
  
  inline MessagePatch& operator=(const MessagePatch& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MessagePatch& default_instance();
  
  void Swap(MessagePatch* other);
  
  // implements Message ----------------------------------------------
  
  MessagePatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessagePatch& from);
  void MergeFrom(const MessagePatch& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string MessageId = 1;
  inline bool has_messageid() const;
  inline void clear_messageid();
  static const int kMessageIdFieldNumber = 1;
  inline const ::std::string& messageid() const;
  inline void set_messageid(const ::std::string& value);
  inline void set_messageid(const char* value);
  inline void set_messageid(const char* value, size_t size);
  inline ::std::string* mutable_messageid();
  inline ::std::string* release_messageid();
  
  // required sfixed64 TimestampTicks = 2;
  inline bool has_timestampticks() const;
  inline void clear_timestampticks();
  static const int kTimestampTicksFieldNumber = 2;
  inline ::google::protobuf::int64 timestampticks() const;
  inline void set_timestampticks(::google::protobuf::int64 value);
  
  // repeated .Diadoc.Api.Proto.Events.Entity Entities = 3;
  inline int entities_size() const;
  inline void clear_entities();
  static const int kEntitiesFieldNumber = 3;
  inline const ::Diadoc::Api::Proto::Events::Entity& entities(int index) const;
  inline ::Diadoc::Api::Proto::Events::Entity* mutable_entities(int index);
  inline ::Diadoc::Api::Proto::Events::Entity* add_entities();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::Entity >&
      entities() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::Entity >*
      mutable_entities();
  
  // optional bool ForDraft = 4 [default = false];
  inline bool has_fordraft() const;
  inline void clear_fordraft();
  static const int kForDraftFieldNumber = 4;
  inline bool fordraft() const;
  inline void set_fordraft(bool value);
  
  // optional bool DraftIsRecycled = 5 [default = false];
  inline bool has_draftisrecycled() const;
  inline void clear_draftisrecycled();
  static const int kDraftIsRecycledFieldNumber = 5;
  inline bool draftisrecycled() const;
  inline void set_draftisrecycled(bool value);
  
  // repeated string DraftIsTransformedToMessageIdList = 6;
  inline int draftistransformedtomessageidlist_size() const;
  inline void clear_draftistransformedtomessageidlist();
  static const int kDraftIsTransformedToMessageIdListFieldNumber = 6;
  inline const ::std::string& draftistransformedtomessageidlist(int index) const;
  inline ::std::string* mutable_draftistransformedtomessageidlist(int index);
  inline void set_draftistransformedtomessageidlist(int index, const ::std::string& value);
  inline void set_draftistransformedtomessageidlist(int index, const char* value);
  inline void set_draftistransformedtomessageidlist(int index, const char* value, size_t size);
  inline ::std::string* add_draftistransformedtomessageidlist();
  inline void add_draftistransformedtomessageidlist(const ::std::string& value);
  inline void add_draftistransformedtomessageidlist(const char* value);
  inline void add_draftistransformedtomessageidlist(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& draftistransformedtomessageidlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_draftistransformedtomessageidlist();
  
  // optional bool DraftIsLocked = 7 [default = false];
  inline bool has_draftislocked() const;
  inline void clear_draftislocked();
  static const int kDraftIsLockedFieldNumber = 7;
  inline bool draftislocked() const;
  inline void set_draftislocked(bool value);
  
  // optional bool MessageIsDeleted = 8 [default = false];
  inline bool has_messageisdeleted() const;
  inline void clear_messageisdeleted();
  static const int kMessageIsDeletedFieldNumber = 8;
  inline bool messageisdeleted() const;
  inline void set_messageisdeleted(bool value);
  
  // repeated .Diadoc.Api.Proto.Events.EntityPatch EntityPatches = 9;
  inline int entitypatches_size() const;
  inline void clear_entitypatches();
  static const int kEntityPatchesFieldNumber = 9;
  inline const ::Diadoc::Api::Proto::Events::EntityPatch& entitypatches(int index) const;
  inline ::Diadoc::Api::Proto::Events::EntityPatch* mutable_entitypatches(int index);
  inline ::Diadoc::Api::Proto::Events::EntityPatch* add_entitypatches();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::EntityPatch >&
      entitypatches() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::EntityPatch >*
      mutable_entitypatches();
  
  // optional bool MessageIsRestored = 10 [default = false];
  inline bool has_messageisrestored() const;
  inline void clear_messageisrestored();
  static const int kMessageIsRestoredFieldNumber = 10;
  inline bool messageisrestored() const;
  inline void set_messageisrestored(bool value);
  
  // optional bool MessageIsDelivered = 11 [default = false];
  inline bool has_messageisdelivered() const;
  inline void clear_messageisdelivered();
  static const int kMessageIsDeliveredFieldNumber = 11;
  inline bool messageisdelivered() const;
  inline void set_messageisdelivered(bool value);
  
  // optional string DeliveredPatchId = 12;
  inline bool has_deliveredpatchid() const;
  inline void clear_deliveredpatchid();
  static const int kDeliveredPatchIdFieldNumber = 12;
  inline const ::std::string& deliveredpatchid() const;
  inline void set_deliveredpatchid(const ::std::string& value);
  inline void set_deliveredpatchid(const char* value);
  inline void set_deliveredpatchid(const char* value, size_t size);
  inline ::std::string* mutable_deliveredpatchid();
  inline ::std::string* release_deliveredpatchid();
  
  // required string PatchId = 13;
  inline bool has_patchid() const;
  inline void clear_patchid();
  static const int kPatchIdFieldNumber = 13;
  inline const ::std::string& patchid() const;
  inline void set_patchid(const ::std::string& value);
  inline void set_patchid(const char* value);
  inline void set_patchid(const char* value, size_t size);
  inline ::std::string* mutable_patchid();
  inline ::std::string* release_patchid();
  
  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.MessagePatch)
 private:
  inline void set_has_messageid();
  inline void clear_has_messageid();
  inline void set_has_timestampticks();
  inline void clear_has_timestampticks();
  inline void set_has_fordraft();
  inline void clear_has_fordraft();
  inline void set_has_draftisrecycled();
  inline void clear_has_draftisrecycled();
  inline void set_has_draftislocked();
  inline void clear_has_draftislocked();
  inline void set_has_messageisdeleted();
  inline void clear_has_messageisdeleted();
  inline void set_has_messageisrestored();
  inline void clear_has_messageisrestored();
  inline void set_has_messageisdelivered();
  inline void clear_has_messageisdelivered();
  inline void set_has_deliveredpatchid();
  inline void clear_has_deliveredpatchid();
  inline void set_has_patchid();
  inline void clear_has_patchid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* messageid_;
  ::google::protobuf::int64 timestampticks_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::Entity > entities_;
  ::google::protobuf::RepeatedPtrField< ::std::string> draftistransformedtomessageidlist_;
  bool fordraft_;
  bool draftisrecycled_;
  bool draftislocked_;
  bool messageisdeleted_;
  bool messageisrestored_;
  bool messageisdelivered_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::EntityPatch > entitypatches_;
  ::std::string* deliveredpatchid_;
  ::std::string* patchid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2eGetApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2eGetApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2eGetApi_2eproto();
  
  void InitAsDefaultInstance();
  static MessagePatch* default_instance_;
};
// -------------------------------------------------------------------

class Entity : public ::google::protobuf::Message {
 public:
  Entity();
  virtual ~Entity();
  
  Entity(const Entity& from);
  
  inline Entity& operator=(const Entity& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Entity& default_instance();
  
  void Swap(Entity* other);
  
  // implements Message ----------------------------------------------
  
  Entity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Entity& from);
  void MergeFrom(const Entity& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Diadoc.Api.Proto.Events.EntityType EntityType = 1 [default = UnknownEntityType];
  inline bool has_entitytype() const;
  inline void clear_entitytype();
  static const int kEntityTypeFieldNumber = 1;
  inline Diadoc::Api::Proto::Events::EntityType entitytype() const;
  inline void set_entitytype(Diadoc::Api::Proto::Events::EntityType value);
  
  // required string EntityId = 2;
  inline bool has_entityid() const;
  inline void clear_entityid();
  static const int kEntityIdFieldNumber = 2;
  inline const ::std::string& entityid() const;
  inline void set_entityid(const ::std::string& value);
  inline void set_entityid(const char* value);
  inline void set_entityid(const char* value, size_t size);
  inline ::std::string* mutable_entityid();
  inline ::std::string* release_entityid();
  
  // optional string ParentEntityId = 3;
  inline bool has_parententityid() const;
  inline void clear_parententityid();
  static const int kParentEntityIdFieldNumber = 3;
  inline const ::std::string& parententityid() const;
  inline void set_parententityid(const ::std::string& value);
  inline void set_parententityid(const char* value);
  inline void set_parententityid(const char* value, size_t size);
  inline ::std::string* mutable_parententityid();
  inline ::std::string* release_parententityid();
  
  // optional .Diadoc.Api.Proto.Content Content = 4;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::Content& content() const;
  inline ::Diadoc::Api::Proto::Content* mutable_content();
  inline ::Diadoc::Api::Proto::Content* release_content();
  
  // optional .Diadoc.Api.Proto.Events.AttachmentType AttachmentType = 5 [default = UnknownAttachmentType];
  inline bool has_attachmenttype() const;
  inline void clear_attachmenttype();
  static const int kAttachmentTypeFieldNumber = 5;
  inline Diadoc::Api::Proto::Events::AttachmentType attachmenttype() const;
  inline void set_attachmenttype(Diadoc::Api::Proto::Events::AttachmentType value);
  
  // optional string FileName = 6;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 6;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  
  // optional bool NeedRecipientSignature = 7 [default = false];
  inline bool has_needrecipientsignature() const;
  inline void clear_needrecipientsignature();
  static const int kNeedRecipientSignatureFieldNumber = 7;
  inline bool needrecipientsignature() const;
  inline void set_needrecipientsignature(bool value);
  
  // optional string SignerBoxId = 8;
  inline bool has_signerboxid() const;
  inline void clear_signerboxid();
  static const int kSignerBoxIdFieldNumber = 8;
  inline const ::std::string& signerboxid() const;
  inline void set_signerboxid(const ::std::string& value);
  inline void set_signerboxid(const char* value);
  inline void set_signerboxid(const char* value, size_t size);
  inline ::std::string* mutable_signerboxid();
  inline ::std::string* release_signerboxid();
  
  // optional string NotDeliveredEventId = 10;
  inline bool has_notdeliveredeventid() const;
  inline void clear_notdeliveredeventid();
  static const int kNotDeliveredEventIdFieldNumber = 10;
  inline const ::std::string& notdeliveredeventid() const;
  inline void set_notdeliveredeventid(const ::std::string& value);
  inline void set_notdeliveredeventid(const char* value);
  inline void set_notdeliveredeventid(const char* value, size_t size);
  inline ::std::string* mutable_notdeliveredeventid();
  inline ::std::string* release_notdeliveredeventid();
  
  // optional .Diadoc.Api.Proto.Documents.Document DocumentInfo = 11;
  inline bool has_documentinfo() const;
  inline void clear_documentinfo();
  static const int kDocumentInfoFieldNumber = 11;
  inline const ::Diadoc::Api::Proto::Documents::Document& documentinfo() const;
  inline ::Diadoc::Api::Proto::Documents::Document* mutable_documentinfo();
  inline ::Diadoc::Api::Proto::Documents::Document* release_documentinfo();
  
  // optional sfixed64 RawCreationDate = 12 [default = 0];
  inline bool has_rawcreationdate() const;
  inline void clear_rawcreationdate();
  static const int kRawCreationDateFieldNumber = 12;
  inline ::google::protobuf::int64 rawcreationdate() const;
  inline void set_rawcreationdate(::google::protobuf::int64 value);
  
  // optional .Diadoc.Api.Proto.Events.ResolutionInfo ResolutionInfo = 13;
  inline bool has_resolutioninfo() const;
  inline void clear_resolutioninfo();
  static const int kResolutionInfoFieldNumber = 13;
  inline const ::Diadoc::Api::Proto::Events::ResolutionInfo& resolutioninfo() const;
  inline ::Diadoc::Api::Proto::Events::ResolutionInfo* mutable_resolutioninfo();
  inline ::Diadoc::Api::Proto::Events::ResolutionInfo* release_resolutioninfo();
  
  // optional string SignerDepartmentId = 14;
  inline bool has_signerdepartmentid() const;
  inline void clear_signerdepartmentid();
  static const int kSignerDepartmentIdFieldNumber = 14;
  inline const ::std::string& signerdepartmentid() const;
  inline void set_signerdepartmentid(const ::std::string& value);
  inline void set_signerdepartmentid(const char* value);
  inline void set_signerdepartmentid(const char* value, size_t size);
  inline ::std::string* mutable_signerdepartmentid();
  inline ::std::string* release_signerdepartmentid();
  
  // optional .Diadoc.Api.Proto.Events.ResolutionRequestInfo ResolutionRequestInfo = 15;
  inline bool has_resolutionrequestinfo() const;
  inline void clear_resolutionrequestinfo();
  static const int kResolutionRequestInfoFieldNumber = 15;
  inline const ::Diadoc::Api::Proto::Events::ResolutionRequestInfo& resolutionrequestinfo() const;
  inline ::Diadoc::Api::Proto::Events::ResolutionRequestInfo* mutable_resolutionrequestinfo();
  inline ::Diadoc::Api::Proto::Events::ResolutionRequestInfo* release_resolutionrequestinfo();
  
  // optional .Diadoc.Api.Proto.Events.ResolutionRequestDenialInfo ResolutionRequestDenialInfo = 16;
  inline bool has_resolutionrequestdenialinfo() const;
  inline void clear_resolutionrequestdenialinfo();
  static const int kResolutionRequestDenialInfoFieldNumber = 16;
  inline const ::Diadoc::Api::Proto::Events::ResolutionRequestDenialInfo& resolutionrequestdenialinfo() const;
  inline ::Diadoc::Api::Proto::Events::ResolutionRequestDenialInfo* mutable_resolutionrequestdenialinfo();
  inline ::Diadoc::Api::Proto::Events::ResolutionRequestDenialInfo* release_resolutionrequestdenialinfo();
  
  // optional bool NeedReceipt = 17 [default = false];
  inline bool has_needreceipt() const;
  inline void clear_needreceipt();
  static const int kNeedReceiptFieldNumber = 17;
  inline bool needreceipt() const;
  inline void set_needreceipt(bool value);
  
  // optional string PacketId = 18;
  inline bool has_packetid() const;
  inline void clear_packetid();
  static const int kPacketIdFieldNumber = 18;
  inline const ::std::string& packetid() const;
  inline void set_packetid(const ::std::string& value);
  inline void set_packetid(const char* value);
  inline void set_packetid(const char* value, size_t size);
  inline ::std::string* mutable_packetid();
  inline ::std::string* release_packetid();
  
  // optional bool IsApprovementSignature = 19 [default = false];
  inline bool has_isapprovementsignature() const;
  inline void clear_isapprovementsignature();
  static const int kIsApprovementSignatureFieldNumber = 19;
  inline bool isapprovementsignature() const;
  inline void set_isapprovementsignature(bool value);
  
  // optional bool IsEncryptedContent = 20 [default = false];
  inline bool has_isencryptedcontent() const;
  inline void clear_isencryptedcontent();
  static const int kIsEncryptedContentFieldNumber = 20;
  inline bool isencryptedcontent() const;
  inline void set_isencryptedcontent(bool value);
  
  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.Entity)
 private:
  inline void set_has_entitytype();
  inline void clear_has_entitytype();
  inline void set_has_entityid();
  inline void clear_has_entityid();
  inline void set_has_parententityid();
  inline void clear_has_parententityid();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_attachmenttype();
  inline void clear_has_attachmenttype();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_needrecipientsignature();
  inline void clear_has_needrecipientsignature();
  inline void set_has_signerboxid();
  inline void clear_has_signerboxid();
  inline void set_has_notdeliveredeventid();
  inline void clear_has_notdeliveredeventid();
  inline void set_has_documentinfo();
  inline void clear_has_documentinfo();
  inline void set_has_rawcreationdate();
  inline void clear_has_rawcreationdate();
  inline void set_has_resolutioninfo();
  inline void clear_has_resolutioninfo();
  inline void set_has_signerdepartmentid();
  inline void clear_has_signerdepartmentid();
  inline void set_has_resolutionrequestinfo();
  inline void clear_has_resolutionrequestinfo();
  inline void set_has_resolutionrequestdenialinfo();
  inline void clear_has_resolutionrequestdenialinfo();
  inline void set_has_needreceipt();
  inline void clear_has_needreceipt();
  inline void set_has_packetid();
  inline void clear_has_packetid();
  inline void set_has_isapprovementsignature();
  inline void clear_has_isapprovementsignature();
  inline void set_has_isencryptedcontent();
  inline void clear_has_isencryptedcontent();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* entityid_;
  ::std::string* parententityid_;
  int entitytype_;
  int attachmenttype_;
  ::Diadoc::Api::Proto::Content* content_;
  ::std::string* filename_;
  ::std::string* signerboxid_;
  ::std::string* notdeliveredeventid_;
  ::Diadoc::Api::Proto::Documents::Document* documentinfo_;
  ::google::protobuf::int64 rawcreationdate_;
  ::Diadoc::Api::Proto::Events::ResolutionInfo* resolutioninfo_;
  ::std::string* signerdepartmentid_;
  ::Diadoc::Api::Proto::Events::ResolutionRequestInfo* resolutionrequestinfo_;
  ::Diadoc::Api::Proto::Events::ResolutionRequestDenialInfo* resolutionrequestdenialinfo_;
  ::std::string* packetid_;
  bool needrecipientsignature_;
  bool needreceipt_;
  bool isapprovementsignature_;
  bool isencryptedcontent_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];
  
  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2eGetApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2eGetApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2eGetApi_2eproto();
  
  void InitAsDefaultInstance();
  static Entity* default_instance_;
};
// -------------------------------------------------------------------

class EntityPatch : public ::google::protobuf::Message {
 public:
  EntityPatch();
  virtual ~EntityPatch();
  
  EntityPatch(const EntityPatch& from);
  
  inline EntityPatch& operator=(const EntityPatch& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityPatch& default_instance();
  
  void Swap(EntityPatch* other);
  
  // implements Message ----------------------------------------------
  
  EntityPatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntityPatch& from);
  void MergeFrom(const EntityPatch& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string EntityId = 1;
  inline bool has_entityid() const;
  inline void clear_entityid();
  static const int kEntityIdFieldNumber = 1;
  inline const ::std::string& entityid() const;
  inline void set_entityid(const ::std::string& value);
  inline void set_entityid(const char* value);
  inline void set_entityid(const char* value, size_t size);
  inline ::std::string* mutable_entityid();
  inline ::std::string* release_entityid();
  
  // optional bool DocumentIsDeleted = 2 [default = false];
  inline bool has_documentisdeleted() const;
  inline void clear_documentisdeleted();
  static const int kDocumentIsDeletedFieldNumber = 2;
  inline bool documentisdeleted() const;
  inline void set_documentisdeleted(bool value);
  
  // optional string MovedToDepartment = 3;
  inline bool has_movedtodepartment() const;
  inline void clear_movedtodepartment();
  static const int kMovedToDepartmentFieldNumber = 3;
  inline const ::std::string& movedtodepartment() const;
  inline void set_movedtodepartment(const ::std::string& value);
  inline void set_movedtodepartment(const char* value);
  inline void set_movedtodepartment(const char* value, size_t size);
  inline ::std::string* mutable_movedtodepartment();
  inline ::std::string* release_movedtodepartment();
  
  // optional bool DocumentIsRestored = 4 [default = false];
  inline bool has_documentisrestored() const;
  inline void clear_documentisrestored();
  static const int kDocumentIsRestoredFieldNumber = 4;
  inline bool documentisrestored() const;
  inline void set_documentisrestored(bool value);
  
  // optional bool ContentIsPatched = 5 [default = false];
  inline bool has_contentispatched() const;
  inline void clear_contentispatched();
  static const int kContentIsPatchedFieldNumber = 5;
  inline bool contentispatched() const;
  inline void set_contentispatched(bool value);
  
  // optional string ForwardedToBoxId = 6;
  inline bool has_forwardedtoboxid() const;
  inline void clear_forwardedtoboxid();
  static const int kForwardedToBoxIdFieldNumber = 6;
  inline const ::std::string& forwardedtoboxid() const;
  inline void set_forwardedtoboxid(const ::std::string& value);
  inline void set_forwardedtoboxid(const char* value);
  inline void set_forwardedtoboxid(const char* value, size_t size);
  inline ::std::string* mutable_forwardedtoboxid();
  inline ::std::string* release_forwardedtoboxid();
  
  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Events.EntityPatch)
 private:
  inline void set_has_entityid();
  inline void clear_has_entityid();
  inline void set_has_documentisdeleted();
  inline void clear_has_documentisdeleted();
  inline void set_has_movedtodepartment();
  inline void clear_has_movedtodepartment();
  inline void set_has_documentisrestored();
  inline void clear_has_documentisrestored();
  inline void set_has_contentispatched();
  inline void clear_has_contentispatched();
  inline void set_has_forwardedtoboxid();
  inline void clear_has_forwardedtoboxid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* entityid_;
  ::std::string* movedtodepartment_;
  ::std::string* forwardedtoboxid_;
  bool documentisdeleted_;
  bool documentisrestored_;
  bool contentispatched_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Events_2fDiadocMessage_2eGetApi_2eproto();
  friend void protobuf_AssignDesc_Events_2fDiadocMessage_2eGetApi_2eproto();
  friend void protobuf_ShutdownFile_Events_2fDiadocMessage_2eGetApi_2eproto();
  
  void InitAsDefaultInstance();
  static EntityPatch* default_instance_;
};
// ===================================================================


// ===================================================================

// BoxEventList

// repeated .Diadoc.Api.Proto.Events.BoxEvent Events = 1;
inline int BoxEventList::events_size() const {
  return events_.size();
}
inline void BoxEventList::clear_events() {
  events_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::BoxEvent& BoxEventList::events(int index) const {
  return events_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::BoxEvent* BoxEventList::mutable_events(int index) {
  return events_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::BoxEvent* BoxEventList::add_events() {
  return events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::BoxEvent >&
BoxEventList::events() const {
  return events_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::BoxEvent >*
BoxEventList::mutable_events() {
  return &events_;
}

// optional int32 TotalCount = 2;
inline bool BoxEventList::has_totalcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoxEventList::set_has_totalcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoxEventList::clear_has_totalcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoxEventList::clear_totalcount() {
  totalcount_ = 0;
  clear_has_totalcount();
}
inline ::google::protobuf::int32 BoxEventList::totalcount() const {
  return totalcount_;
}
inline void BoxEventList::set_totalcount(::google::protobuf::int32 value) {
  set_has_totalcount();
  totalcount_ = value;
}

// -------------------------------------------------------------------

// BoxEvent

// required string EventId = 1;
inline bool BoxEvent::has_eventid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoxEvent::set_has_eventid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoxEvent::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoxEvent::clear_eventid() {
  if (eventid_ != &::google::protobuf::internal::kEmptyString) {
    eventid_->clear();
  }
  clear_has_eventid();
}
inline const ::std::string& BoxEvent::eventid() const {
  return *eventid_;
}
inline void BoxEvent::set_eventid(const ::std::string& value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void BoxEvent::set_eventid(const char* value) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(value);
}
inline void BoxEvent::set_eventid(const char* value, size_t size) {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  eventid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BoxEvent::mutable_eventid() {
  set_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    eventid_ = new ::std::string;
  }
  return eventid_;
}
inline ::std::string* BoxEvent::release_eventid() {
  clear_has_eventid();
  if (eventid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventid_;
    eventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .Diadoc.Api.Proto.Events.Message Message = 2;
inline bool BoxEvent::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoxEvent::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoxEvent::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoxEvent::clear_message() {
  if (message_ != NULL) message_->::Diadoc::Api::Proto::Events::Message::Clear();
  clear_has_message();
}
inline const ::Diadoc::Api::Proto::Events::Message& BoxEvent::message() const {
  return message_ != NULL ? *message_ : *default_instance_->message_;
}
inline ::Diadoc::Api::Proto::Events::Message* BoxEvent::mutable_message() {
  set_has_message();
  if (message_ == NULL) message_ = new ::Diadoc::Api::Proto::Events::Message;
  return message_;
}
inline ::Diadoc::Api::Proto::Events::Message* BoxEvent::release_message() {
  clear_has_message();
  ::Diadoc::Api::Proto::Events::Message* temp = message_;
  message_ = NULL;
  return temp;
}

// optional .Diadoc.Api.Proto.Events.MessagePatch Patch = 3;
inline bool BoxEvent::has_patch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BoxEvent::set_has_patch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BoxEvent::clear_has_patch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BoxEvent::clear_patch() {
  if (patch_ != NULL) patch_->::Diadoc::Api::Proto::Events::MessagePatch::Clear();
  clear_has_patch();
}
inline const ::Diadoc::Api::Proto::Events::MessagePatch& BoxEvent::patch() const {
  return patch_ != NULL ? *patch_ : *default_instance_->patch_;
}
inline ::Diadoc::Api::Proto::Events::MessagePatch* BoxEvent::mutable_patch() {
  set_has_patch();
  if (patch_ == NULL) patch_ = new ::Diadoc::Api::Proto::Events::MessagePatch;
  return patch_;
}
inline ::Diadoc::Api::Proto::Events::MessagePatch* BoxEvent::release_patch() {
  clear_has_patch();
  ::Diadoc::Api::Proto::Events::MessagePatch* temp = patch_;
  patch_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Message

// required string MessageId = 1;
inline bool Message::has_messageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_messageid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_messageid() {
  if (messageid_ != &::google::protobuf::internal::kEmptyString) {
    messageid_->clear();
  }
  clear_has_messageid();
}
inline const ::std::string& Message::messageid() const {
  return *messageid_;
}
inline void Message::set_messageid(const ::std::string& value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
}
inline void Message::set_messageid(const char* value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
}
inline void Message::set_messageid(const char* value, size_t size) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_messageid() {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  return messageid_;
}
inline ::std::string* Message::release_messageid() {
  clear_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = messageid_;
    messageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required sfixed64 TimestampTicks = 2;
inline bool Message::has_timestampticks() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_timestampticks() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_timestampticks() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_timestampticks() {
  timestampticks_ = GOOGLE_LONGLONG(0);
  clear_has_timestampticks();
}
inline ::google::protobuf::int64 Message::timestampticks() const {
  return timestampticks_;
}
inline void Message::set_timestampticks(::google::protobuf::int64 value) {
  set_has_timestampticks();
  timestampticks_ = value;
}

// required sfixed64 LastPatchTimestampTicks = 3;
inline bool Message::has_lastpatchtimestampticks() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_lastpatchtimestampticks() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_lastpatchtimestampticks() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_lastpatchtimestampticks() {
  lastpatchtimestampticks_ = GOOGLE_LONGLONG(0);
  clear_has_lastpatchtimestampticks();
}
inline ::google::protobuf::int64 Message::lastpatchtimestampticks() const {
  return lastpatchtimestampticks_;
}
inline void Message::set_lastpatchtimestampticks(::google::protobuf::int64 value) {
  set_has_lastpatchtimestampticks();
  lastpatchtimestampticks_ = value;
}

// required string FromBoxId = 4;
inline bool Message::has_fromboxid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_fromboxid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_fromboxid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_fromboxid() {
  if (fromboxid_ != &::google::protobuf::internal::kEmptyString) {
    fromboxid_->clear();
  }
  clear_has_fromboxid();
}
inline const ::std::string& Message::fromboxid() const {
  return *fromboxid_;
}
inline void Message::set_fromboxid(const ::std::string& value) {
  set_has_fromboxid();
  if (fromboxid_ == &::google::protobuf::internal::kEmptyString) {
    fromboxid_ = new ::std::string;
  }
  fromboxid_->assign(value);
}
inline void Message::set_fromboxid(const char* value) {
  set_has_fromboxid();
  if (fromboxid_ == &::google::protobuf::internal::kEmptyString) {
    fromboxid_ = new ::std::string;
  }
  fromboxid_->assign(value);
}
inline void Message::set_fromboxid(const char* value, size_t size) {
  set_has_fromboxid();
  if (fromboxid_ == &::google::protobuf::internal::kEmptyString) {
    fromboxid_ = new ::std::string;
  }
  fromboxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_fromboxid() {
  set_has_fromboxid();
  if (fromboxid_ == &::google::protobuf::internal::kEmptyString) {
    fromboxid_ = new ::std::string;
  }
  return fromboxid_;
}
inline ::std::string* Message::release_fromboxid() {
  clear_has_fromboxid();
  if (fromboxid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromboxid_;
    fromboxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string FromTitle = 5;
inline bool Message::has_fromtitle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message::set_has_fromtitle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message::clear_has_fromtitle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message::clear_fromtitle() {
  if (fromtitle_ != &::google::protobuf::internal::kEmptyString) {
    fromtitle_->clear();
  }
  clear_has_fromtitle();
}
inline const ::std::string& Message::fromtitle() const {
  return *fromtitle_;
}
inline void Message::set_fromtitle(const ::std::string& value) {
  set_has_fromtitle();
  if (fromtitle_ == &::google::protobuf::internal::kEmptyString) {
    fromtitle_ = new ::std::string;
  }
  fromtitle_->assign(value);
}
inline void Message::set_fromtitle(const char* value) {
  set_has_fromtitle();
  if (fromtitle_ == &::google::protobuf::internal::kEmptyString) {
    fromtitle_ = new ::std::string;
  }
  fromtitle_->assign(value);
}
inline void Message::set_fromtitle(const char* value, size_t size) {
  set_has_fromtitle();
  if (fromtitle_ == &::google::protobuf::internal::kEmptyString) {
    fromtitle_ = new ::std::string;
  }
  fromtitle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_fromtitle() {
  set_has_fromtitle();
  if (fromtitle_ == &::google::protobuf::internal::kEmptyString) {
    fromtitle_ = new ::std::string;
  }
  return fromtitle_;
}
inline ::std::string* Message::release_fromtitle() {
  clear_has_fromtitle();
  if (fromtitle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromtitle_;
    fromtitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ToBoxId = 6;
inline bool Message::has_toboxid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message::set_has_toboxid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message::clear_has_toboxid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message::clear_toboxid() {
  if (toboxid_ != &::google::protobuf::internal::kEmptyString) {
    toboxid_->clear();
  }
  clear_has_toboxid();
}
inline const ::std::string& Message::toboxid() const {
  return *toboxid_;
}
inline void Message::set_toboxid(const ::std::string& value) {
  set_has_toboxid();
  if (toboxid_ == &::google::protobuf::internal::kEmptyString) {
    toboxid_ = new ::std::string;
  }
  toboxid_->assign(value);
}
inline void Message::set_toboxid(const char* value) {
  set_has_toboxid();
  if (toboxid_ == &::google::protobuf::internal::kEmptyString) {
    toboxid_ = new ::std::string;
  }
  toboxid_->assign(value);
}
inline void Message::set_toboxid(const char* value, size_t size) {
  set_has_toboxid();
  if (toboxid_ == &::google::protobuf::internal::kEmptyString) {
    toboxid_ = new ::std::string;
  }
  toboxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_toboxid() {
  set_has_toboxid();
  if (toboxid_ == &::google::protobuf::internal::kEmptyString) {
    toboxid_ = new ::std::string;
  }
  return toboxid_;
}
inline ::std::string* Message::release_toboxid() {
  clear_has_toboxid();
  if (toboxid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = toboxid_;
    toboxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ToTitle = 7;
inline bool Message::has_totitle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Message::set_has_totitle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Message::clear_has_totitle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Message::clear_totitle() {
  if (totitle_ != &::google::protobuf::internal::kEmptyString) {
    totitle_->clear();
  }
  clear_has_totitle();
}
inline const ::std::string& Message::totitle() const {
  return *totitle_;
}
inline void Message::set_totitle(const ::std::string& value) {
  set_has_totitle();
  if (totitle_ == &::google::protobuf::internal::kEmptyString) {
    totitle_ = new ::std::string;
  }
  totitle_->assign(value);
}
inline void Message::set_totitle(const char* value) {
  set_has_totitle();
  if (totitle_ == &::google::protobuf::internal::kEmptyString) {
    totitle_ = new ::std::string;
  }
  totitle_->assign(value);
}
inline void Message::set_totitle(const char* value, size_t size) {
  set_has_totitle();
  if (totitle_ == &::google::protobuf::internal::kEmptyString) {
    totitle_ = new ::std::string;
  }
  totitle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_totitle() {
  set_has_totitle();
  if (totitle_ == &::google::protobuf::internal::kEmptyString) {
    totitle_ = new ::std::string;
  }
  return totitle_;
}
inline ::std::string* Message::release_totitle() {
  clear_has_totitle();
  if (totitle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = totitle_;
    totitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .Diadoc.Api.Proto.Events.Entity Entities = 8;
inline int Message::entities_size() const {
  return entities_.size();
}
inline void Message::clear_entities() {
  entities_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::Entity& Message::entities(int index) const {
  return entities_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::Entity* Message::mutable_entities(int index) {
  return entities_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::Entity* Message::add_entities() {
  return entities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::Entity >&
Message::entities() const {
  return entities_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::Entity >*
Message::mutable_entities() {
  return &entities_;
}

// optional bool IsDraft = 9 [default = false];
inline bool Message::has_isdraft() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Message::set_has_isdraft() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Message::clear_has_isdraft() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Message::clear_isdraft() {
  isdraft_ = false;
  clear_has_isdraft();
}
inline bool Message::isdraft() const {
  return isdraft_;
}
inline void Message::set_isdraft(bool value) {
  set_has_isdraft();
  isdraft_ = value;
}

// optional bool DraftIsLocked = 10 [default = false];
inline bool Message::has_draftislocked() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Message::set_has_draftislocked() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Message::clear_has_draftislocked() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Message::clear_draftislocked() {
  draftislocked_ = false;
  clear_has_draftislocked();
}
inline bool Message::draftislocked() const {
  return draftislocked_;
}
inline void Message::set_draftislocked(bool value) {
  set_has_draftislocked();
  draftislocked_ = value;
}

// optional bool DraftIsRecycled = 11 [default = false];
inline bool Message::has_draftisrecycled() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Message::set_has_draftisrecycled() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Message::clear_has_draftisrecycled() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Message::clear_draftisrecycled() {
  draftisrecycled_ = false;
  clear_has_draftisrecycled();
}
inline bool Message::draftisrecycled() const {
  return draftisrecycled_;
}
inline void Message::set_draftisrecycled(bool value) {
  set_has_draftisrecycled();
  draftisrecycled_ = value;
}

// optional string CreatedFromDraftId = 12;
inline bool Message::has_createdfromdraftid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Message::set_has_createdfromdraftid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Message::clear_has_createdfromdraftid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Message::clear_createdfromdraftid() {
  if (createdfromdraftid_ != &::google::protobuf::internal::kEmptyString) {
    createdfromdraftid_->clear();
  }
  clear_has_createdfromdraftid();
}
inline const ::std::string& Message::createdfromdraftid() const {
  return *createdfromdraftid_;
}
inline void Message::set_createdfromdraftid(const ::std::string& value) {
  set_has_createdfromdraftid();
  if (createdfromdraftid_ == &::google::protobuf::internal::kEmptyString) {
    createdfromdraftid_ = new ::std::string;
  }
  createdfromdraftid_->assign(value);
}
inline void Message::set_createdfromdraftid(const char* value) {
  set_has_createdfromdraftid();
  if (createdfromdraftid_ == &::google::protobuf::internal::kEmptyString) {
    createdfromdraftid_ = new ::std::string;
  }
  createdfromdraftid_->assign(value);
}
inline void Message::set_createdfromdraftid(const char* value, size_t size) {
  set_has_createdfromdraftid();
  if (createdfromdraftid_ == &::google::protobuf::internal::kEmptyString) {
    createdfromdraftid_ = new ::std::string;
  }
  createdfromdraftid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_createdfromdraftid() {
  set_has_createdfromdraftid();
  if (createdfromdraftid_ == &::google::protobuf::internal::kEmptyString) {
    createdfromdraftid_ = new ::std::string;
  }
  return createdfromdraftid_;
}
inline ::std::string* Message::release_createdfromdraftid() {
  clear_has_createdfromdraftid();
  if (createdfromdraftid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = createdfromdraftid_;
    createdfromdraftid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string DraftIsTransformedToMessageIdList = 13;
inline int Message::draftistransformedtomessageidlist_size() const {
  return draftistransformedtomessageidlist_.size();
}
inline void Message::clear_draftistransformedtomessageidlist() {
  draftistransformedtomessageidlist_.Clear();
}
inline const ::std::string& Message::draftistransformedtomessageidlist(int index) const {
  return draftistransformedtomessageidlist_.Get(index);
}
inline ::std::string* Message::mutable_draftistransformedtomessageidlist(int index) {
  return draftistransformedtomessageidlist_.Mutable(index);
}
inline void Message::set_draftistransformedtomessageidlist(int index, const ::std::string& value) {
  draftistransformedtomessageidlist_.Mutable(index)->assign(value);
}
inline void Message::set_draftistransformedtomessageidlist(int index, const char* value) {
  draftistransformedtomessageidlist_.Mutable(index)->assign(value);
}
inline void Message::set_draftistransformedtomessageidlist(int index, const char* value, size_t size) {
  draftistransformedtomessageidlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::add_draftistransformedtomessageidlist() {
  return draftistransformedtomessageidlist_.Add();
}
inline void Message::add_draftistransformedtomessageidlist(const ::std::string& value) {
  draftistransformedtomessageidlist_.Add()->assign(value);
}
inline void Message::add_draftistransformedtomessageidlist(const char* value) {
  draftistransformedtomessageidlist_.Add()->assign(value);
}
inline void Message::add_draftistransformedtomessageidlist(const char* value, size_t size) {
  draftistransformedtomessageidlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Message::draftistransformedtomessageidlist() const {
  return draftistransformedtomessageidlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Message::mutable_draftistransformedtomessageidlist() {
  return &draftistransformedtomessageidlist_;
}

// optional bool IsDeleted = 14 [default = false];
inline bool Message::has_isdeleted() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Message::set_has_isdeleted() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Message::clear_has_isdeleted() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Message::clear_isdeleted() {
  isdeleted_ = false;
  clear_has_isdeleted();
}
inline bool Message::isdeleted() const {
  return isdeleted_;
}
inline void Message::set_isdeleted(bool value) {
  set_has_isdeleted();
  isdeleted_ = value;
}

// optional bool IsTest = 15 [default = false];
inline bool Message::has_istest() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Message::set_has_istest() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Message::clear_has_istest() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Message::clear_istest() {
  istest_ = false;
  clear_has_istest();
}
inline bool Message::istest() const {
  return istest_;
}
inline void Message::set_istest(bool value) {
  set_has_istest();
  istest_ = value;
}

// optional bool IsInternal = 16 [default = false];
inline bool Message::has_isinternal() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Message::set_has_isinternal() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Message::clear_has_isinternal() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Message::clear_isinternal() {
  isinternal_ = false;
  clear_has_isinternal();
}
inline bool Message::isinternal() const {
  return isinternal_;
}
inline void Message::set_isinternal(bool value) {
  set_has_isinternal();
  isinternal_ = value;
}

// optional bool IsProxified = 17 [default = false];
inline bool Message::has_isproxified() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Message::set_has_isproxified() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Message::clear_has_isproxified() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Message::clear_isproxified() {
  isproxified_ = false;
  clear_has_isproxified();
}
inline bool Message::isproxified() const {
  return isproxified_;
}
inline void Message::set_isproxified(bool value) {
  set_has_isproxified();
  isproxified_ = value;
}

// optional string ProxyBoxId = 18;
inline bool Message::has_proxyboxid() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Message::set_has_proxyboxid() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Message::clear_has_proxyboxid() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Message::clear_proxyboxid() {
  if (proxyboxid_ != &::google::protobuf::internal::kEmptyString) {
    proxyboxid_->clear();
  }
  clear_has_proxyboxid();
}
inline const ::std::string& Message::proxyboxid() const {
  return *proxyboxid_;
}
inline void Message::set_proxyboxid(const ::std::string& value) {
  set_has_proxyboxid();
  if (proxyboxid_ == &::google::protobuf::internal::kEmptyString) {
    proxyboxid_ = new ::std::string;
  }
  proxyboxid_->assign(value);
}
inline void Message::set_proxyboxid(const char* value) {
  set_has_proxyboxid();
  if (proxyboxid_ == &::google::protobuf::internal::kEmptyString) {
    proxyboxid_ = new ::std::string;
  }
  proxyboxid_->assign(value);
}
inline void Message::set_proxyboxid(const char* value, size_t size) {
  set_has_proxyboxid();
  if (proxyboxid_ == &::google::protobuf::internal::kEmptyString) {
    proxyboxid_ = new ::std::string;
  }
  proxyboxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_proxyboxid() {
  set_has_proxyboxid();
  if (proxyboxid_ == &::google::protobuf::internal::kEmptyString) {
    proxyboxid_ = new ::std::string;
  }
  return proxyboxid_;
}
inline ::std::string* Message::release_proxyboxid() {
  clear_has_proxyboxid();
  if (proxyboxid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proxyboxid_;
    proxyboxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ProxyTitle = 19;
inline bool Message::has_proxytitle() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Message::set_has_proxytitle() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Message::clear_has_proxytitle() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Message::clear_proxytitle() {
  if (proxytitle_ != &::google::protobuf::internal::kEmptyString) {
    proxytitle_->clear();
  }
  clear_has_proxytitle();
}
inline const ::std::string& Message::proxytitle() const {
  return *proxytitle_;
}
inline void Message::set_proxytitle(const ::std::string& value) {
  set_has_proxytitle();
  if (proxytitle_ == &::google::protobuf::internal::kEmptyString) {
    proxytitle_ = new ::std::string;
  }
  proxytitle_->assign(value);
}
inline void Message::set_proxytitle(const char* value) {
  set_has_proxytitle();
  if (proxytitle_ == &::google::protobuf::internal::kEmptyString) {
    proxytitle_ = new ::std::string;
  }
  proxytitle_->assign(value);
}
inline void Message::set_proxytitle(const char* value, size_t size) {
  set_has_proxytitle();
  if (proxytitle_ == &::google::protobuf::internal::kEmptyString) {
    proxytitle_ = new ::std::string;
  }
  proxytitle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_proxytitle() {
  set_has_proxytitle();
  if (proxytitle_ == &::google::protobuf::internal::kEmptyString) {
    proxytitle_ = new ::std::string;
  }
  return proxytitle_;
}
inline ::std::string* Message::release_proxytitle() {
  clear_has_proxytitle();
  if (proxytitle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proxytitle_;
    proxytitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool PacketIsLocked = 20 [default = false];
inline bool Message::has_packetislocked() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Message::set_has_packetislocked() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Message::clear_has_packetislocked() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Message::clear_packetislocked() {
  packetislocked_ = false;
  clear_has_packetislocked();
}
inline bool Message::packetislocked() const {
  return packetislocked_;
}
inline void Message::set_packetislocked(bool value) {
  set_has_packetislocked();
  packetislocked_ = value;
}

// -------------------------------------------------------------------

// MessagePatch

// required string MessageId = 1;
inline bool MessagePatch::has_messageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessagePatch::set_has_messageid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessagePatch::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessagePatch::clear_messageid() {
  if (messageid_ != &::google::protobuf::internal::kEmptyString) {
    messageid_->clear();
  }
  clear_has_messageid();
}
inline const ::std::string& MessagePatch::messageid() const {
  return *messageid_;
}
inline void MessagePatch::set_messageid(const ::std::string& value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
}
inline void MessagePatch::set_messageid(const char* value) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(value);
}
inline void MessagePatch::set_messageid(const char* value, size_t size) {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  messageid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessagePatch::mutable_messageid() {
  set_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    messageid_ = new ::std::string;
  }
  return messageid_;
}
inline ::std::string* MessagePatch::release_messageid() {
  clear_has_messageid();
  if (messageid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = messageid_;
    messageid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required sfixed64 TimestampTicks = 2;
inline bool MessagePatch::has_timestampticks() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessagePatch::set_has_timestampticks() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessagePatch::clear_has_timestampticks() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessagePatch::clear_timestampticks() {
  timestampticks_ = GOOGLE_LONGLONG(0);
  clear_has_timestampticks();
}
inline ::google::protobuf::int64 MessagePatch::timestampticks() const {
  return timestampticks_;
}
inline void MessagePatch::set_timestampticks(::google::protobuf::int64 value) {
  set_has_timestampticks();
  timestampticks_ = value;
}

// repeated .Diadoc.Api.Proto.Events.Entity Entities = 3;
inline int MessagePatch::entities_size() const {
  return entities_.size();
}
inline void MessagePatch::clear_entities() {
  entities_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::Entity& MessagePatch::entities(int index) const {
  return entities_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::Entity* MessagePatch::mutable_entities(int index) {
  return entities_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::Entity* MessagePatch::add_entities() {
  return entities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::Entity >&
MessagePatch::entities() const {
  return entities_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::Entity >*
MessagePatch::mutable_entities() {
  return &entities_;
}

// optional bool ForDraft = 4 [default = false];
inline bool MessagePatch::has_fordraft() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessagePatch::set_has_fordraft() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessagePatch::clear_has_fordraft() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessagePatch::clear_fordraft() {
  fordraft_ = false;
  clear_has_fordraft();
}
inline bool MessagePatch::fordraft() const {
  return fordraft_;
}
inline void MessagePatch::set_fordraft(bool value) {
  set_has_fordraft();
  fordraft_ = value;
}

// optional bool DraftIsRecycled = 5 [default = false];
inline bool MessagePatch::has_draftisrecycled() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MessagePatch::set_has_draftisrecycled() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MessagePatch::clear_has_draftisrecycled() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MessagePatch::clear_draftisrecycled() {
  draftisrecycled_ = false;
  clear_has_draftisrecycled();
}
inline bool MessagePatch::draftisrecycled() const {
  return draftisrecycled_;
}
inline void MessagePatch::set_draftisrecycled(bool value) {
  set_has_draftisrecycled();
  draftisrecycled_ = value;
}

// repeated string DraftIsTransformedToMessageIdList = 6;
inline int MessagePatch::draftistransformedtomessageidlist_size() const {
  return draftistransformedtomessageidlist_.size();
}
inline void MessagePatch::clear_draftistransformedtomessageidlist() {
  draftistransformedtomessageidlist_.Clear();
}
inline const ::std::string& MessagePatch::draftistransformedtomessageidlist(int index) const {
  return draftistransformedtomessageidlist_.Get(index);
}
inline ::std::string* MessagePatch::mutable_draftistransformedtomessageidlist(int index) {
  return draftistransformedtomessageidlist_.Mutable(index);
}
inline void MessagePatch::set_draftistransformedtomessageidlist(int index, const ::std::string& value) {
  draftistransformedtomessageidlist_.Mutable(index)->assign(value);
}
inline void MessagePatch::set_draftistransformedtomessageidlist(int index, const char* value) {
  draftistransformedtomessageidlist_.Mutable(index)->assign(value);
}
inline void MessagePatch::set_draftistransformedtomessageidlist(int index, const char* value, size_t size) {
  draftistransformedtomessageidlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessagePatch::add_draftistransformedtomessageidlist() {
  return draftistransformedtomessageidlist_.Add();
}
inline void MessagePatch::add_draftistransformedtomessageidlist(const ::std::string& value) {
  draftistransformedtomessageidlist_.Add()->assign(value);
}
inline void MessagePatch::add_draftistransformedtomessageidlist(const char* value) {
  draftistransformedtomessageidlist_.Add()->assign(value);
}
inline void MessagePatch::add_draftistransformedtomessageidlist(const char* value, size_t size) {
  draftistransformedtomessageidlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MessagePatch::draftistransformedtomessageidlist() const {
  return draftistransformedtomessageidlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MessagePatch::mutable_draftistransformedtomessageidlist() {
  return &draftistransformedtomessageidlist_;
}

// optional bool DraftIsLocked = 7 [default = false];
inline bool MessagePatch::has_draftislocked() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MessagePatch::set_has_draftislocked() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MessagePatch::clear_has_draftislocked() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MessagePatch::clear_draftislocked() {
  draftislocked_ = false;
  clear_has_draftislocked();
}
inline bool MessagePatch::draftislocked() const {
  return draftislocked_;
}
inline void MessagePatch::set_draftislocked(bool value) {
  set_has_draftislocked();
  draftislocked_ = value;
}

// optional bool MessageIsDeleted = 8 [default = false];
inline bool MessagePatch::has_messageisdeleted() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MessagePatch::set_has_messageisdeleted() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MessagePatch::clear_has_messageisdeleted() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MessagePatch::clear_messageisdeleted() {
  messageisdeleted_ = false;
  clear_has_messageisdeleted();
}
inline bool MessagePatch::messageisdeleted() const {
  return messageisdeleted_;
}
inline void MessagePatch::set_messageisdeleted(bool value) {
  set_has_messageisdeleted();
  messageisdeleted_ = value;
}

// repeated .Diadoc.Api.Proto.Events.EntityPatch EntityPatches = 9;
inline int MessagePatch::entitypatches_size() const {
  return entitypatches_.size();
}
inline void MessagePatch::clear_entitypatches() {
  entitypatches_.Clear();
}
inline const ::Diadoc::Api::Proto::Events::EntityPatch& MessagePatch::entitypatches(int index) const {
  return entitypatches_.Get(index);
}
inline ::Diadoc::Api::Proto::Events::EntityPatch* MessagePatch::mutable_entitypatches(int index) {
  return entitypatches_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Events::EntityPatch* MessagePatch::add_entitypatches() {
  return entitypatches_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::EntityPatch >&
MessagePatch::entitypatches() const {
  return entitypatches_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Events::EntityPatch >*
MessagePatch::mutable_entitypatches() {
  return &entitypatches_;
}

// optional bool MessageIsRestored = 10 [default = false];
inline bool MessagePatch::has_messageisrestored() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MessagePatch::set_has_messageisrestored() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MessagePatch::clear_has_messageisrestored() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MessagePatch::clear_messageisrestored() {
  messageisrestored_ = false;
  clear_has_messageisrestored();
}
inline bool MessagePatch::messageisrestored() const {
  return messageisrestored_;
}
inline void MessagePatch::set_messageisrestored(bool value) {
  set_has_messageisrestored();
  messageisrestored_ = value;
}

// optional bool MessageIsDelivered = 11 [default = false];
inline bool MessagePatch::has_messageisdelivered() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MessagePatch::set_has_messageisdelivered() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MessagePatch::clear_has_messageisdelivered() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MessagePatch::clear_messageisdelivered() {
  messageisdelivered_ = false;
  clear_has_messageisdelivered();
}
inline bool MessagePatch::messageisdelivered() const {
  return messageisdelivered_;
}
inline void MessagePatch::set_messageisdelivered(bool value) {
  set_has_messageisdelivered();
  messageisdelivered_ = value;
}

// optional string DeliveredPatchId = 12;
inline bool MessagePatch::has_deliveredpatchid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MessagePatch::set_has_deliveredpatchid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MessagePatch::clear_has_deliveredpatchid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MessagePatch::clear_deliveredpatchid() {
  if (deliveredpatchid_ != &::google::protobuf::internal::kEmptyString) {
    deliveredpatchid_->clear();
  }
  clear_has_deliveredpatchid();
}
inline const ::std::string& MessagePatch::deliveredpatchid() const {
  return *deliveredpatchid_;
}
inline void MessagePatch::set_deliveredpatchid(const ::std::string& value) {
  set_has_deliveredpatchid();
  if (deliveredpatchid_ == &::google::protobuf::internal::kEmptyString) {
    deliveredpatchid_ = new ::std::string;
  }
  deliveredpatchid_->assign(value);
}
inline void MessagePatch::set_deliveredpatchid(const char* value) {
  set_has_deliveredpatchid();
  if (deliveredpatchid_ == &::google::protobuf::internal::kEmptyString) {
    deliveredpatchid_ = new ::std::string;
  }
  deliveredpatchid_->assign(value);
}
inline void MessagePatch::set_deliveredpatchid(const char* value, size_t size) {
  set_has_deliveredpatchid();
  if (deliveredpatchid_ == &::google::protobuf::internal::kEmptyString) {
    deliveredpatchid_ = new ::std::string;
  }
  deliveredpatchid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessagePatch::mutable_deliveredpatchid() {
  set_has_deliveredpatchid();
  if (deliveredpatchid_ == &::google::protobuf::internal::kEmptyString) {
    deliveredpatchid_ = new ::std::string;
  }
  return deliveredpatchid_;
}
inline ::std::string* MessagePatch::release_deliveredpatchid() {
  clear_has_deliveredpatchid();
  if (deliveredpatchid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deliveredpatchid_;
    deliveredpatchid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string PatchId = 13;
inline bool MessagePatch::has_patchid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MessagePatch::set_has_patchid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MessagePatch::clear_has_patchid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MessagePatch::clear_patchid() {
  if (patchid_ != &::google::protobuf::internal::kEmptyString) {
    patchid_->clear();
  }
  clear_has_patchid();
}
inline const ::std::string& MessagePatch::patchid() const {
  return *patchid_;
}
inline void MessagePatch::set_patchid(const ::std::string& value) {
  set_has_patchid();
  if (patchid_ == &::google::protobuf::internal::kEmptyString) {
    patchid_ = new ::std::string;
  }
  patchid_->assign(value);
}
inline void MessagePatch::set_patchid(const char* value) {
  set_has_patchid();
  if (patchid_ == &::google::protobuf::internal::kEmptyString) {
    patchid_ = new ::std::string;
  }
  patchid_->assign(value);
}
inline void MessagePatch::set_patchid(const char* value, size_t size) {
  set_has_patchid();
  if (patchid_ == &::google::protobuf::internal::kEmptyString) {
    patchid_ = new ::std::string;
  }
  patchid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessagePatch::mutable_patchid() {
  set_has_patchid();
  if (patchid_ == &::google::protobuf::internal::kEmptyString) {
    patchid_ = new ::std::string;
  }
  return patchid_;
}
inline ::std::string* MessagePatch::release_patchid() {
  clear_has_patchid();
  if (patchid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patchid_;
    patchid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Entity

// optional .Diadoc.Api.Proto.Events.EntityType EntityType = 1 [default = UnknownEntityType];
inline bool Entity::has_entitytype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Entity::set_has_entitytype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Entity::clear_has_entitytype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Entity::clear_entitytype() {
  entitytype_ = 0;
  clear_has_entitytype();
}
inline Diadoc::Api::Proto::Events::EntityType Entity::entitytype() const {
  return static_cast< Diadoc::Api::Proto::Events::EntityType >(entitytype_);
}
inline void Entity::set_entitytype(Diadoc::Api::Proto::Events::EntityType value) {
  GOOGLE_DCHECK(Diadoc::Api::Proto::Events::EntityType_IsValid(value));
  set_has_entitytype();
  entitytype_ = value;
}

// required string EntityId = 2;
inline bool Entity::has_entityid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Entity::set_has_entityid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Entity::clear_has_entityid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Entity::clear_entityid() {
  if (entityid_ != &::google::protobuf::internal::kEmptyString) {
    entityid_->clear();
  }
  clear_has_entityid();
}
inline const ::std::string& Entity::entityid() const {
  return *entityid_;
}
inline void Entity::set_entityid(const ::std::string& value) {
  set_has_entityid();
  if (entityid_ == &::google::protobuf::internal::kEmptyString) {
    entityid_ = new ::std::string;
  }
  entityid_->assign(value);
}
inline void Entity::set_entityid(const char* value) {
  set_has_entityid();
  if (entityid_ == &::google::protobuf::internal::kEmptyString) {
    entityid_ = new ::std::string;
  }
  entityid_->assign(value);
}
inline void Entity::set_entityid(const char* value, size_t size) {
  set_has_entityid();
  if (entityid_ == &::google::protobuf::internal::kEmptyString) {
    entityid_ = new ::std::string;
  }
  entityid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Entity::mutable_entityid() {
  set_has_entityid();
  if (entityid_ == &::google::protobuf::internal::kEmptyString) {
    entityid_ = new ::std::string;
  }
  return entityid_;
}
inline ::std::string* Entity::release_entityid() {
  clear_has_entityid();
  if (entityid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entityid_;
    entityid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ParentEntityId = 3;
inline bool Entity::has_parententityid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Entity::set_has_parententityid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Entity::clear_has_parententityid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Entity::clear_parententityid() {
  if (parententityid_ != &::google::protobuf::internal::kEmptyString) {
    parententityid_->clear();
  }
  clear_has_parententityid();
}
inline const ::std::string& Entity::parententityid() const {
  return *parententityid_;
}
inline void Entity::set_parententityid(const ::std::string& value) {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  parententityid_->assign(value);
}
inline void Entity::set_parententityid(const char* value) {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  parententityid_->assign(value);
}
inline void Entity::set_parententityid(const char* value, size_t size) {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  parententityid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Entity::mutable_parententityid() {
  set_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    parententityid_ = new ::std::string;
  }
  return parententityid_;
}
inline ::std::string* Entity::release_parententityid() {
  clear_has_parententityid();
  if (parententityid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parententityid_;
    parententityid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .Diadoc.Api.Proto.Content Content = 4;
inline bool Entity::has_content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Entity::set_has_content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Entity::clear_has_content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Entity::clear_content() {
  if (content_ != NULL) content_->::Diadoc::Api::Proto::Content::Clear();
  clear_has_content();
}
inline const ::Diadoc::Api::Proto::Content& Entity::content() const {
  return content_ != NULL ? *content_ : *default_instance_->content_;
}
inline ::Diadoc::Api::Proto::Content* Entity::mutable_content() {
  set_has_content();
  if (content_ == NULL) content_ = new ::Diadoc::Api::Proto::Content;
  return content_;
}
inline ::Diadoc::Api::Proto::Content* Entity::release_content() {
  clear_has_content();
  ::Diadoc::Api::Proto::Content* temp = content_;
  content_ = NULL;
  return temp;
}

// optional .Diadoc.Api.Proto.Events.AttachmentType AttachmentType = 5 [default = UnknownAttachmentType];
inline bool Entity::has_attachmenttype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Entity::set_has_attachmenttype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Entity::clear_has_attachmenttype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Entity::clear_attachmenttype() {
  attachmenttype_ = -1;
  clear_has_attachmenttype();
}
inline Diadoc::Api::Proto::Events::AttachmentType Entity::attachmenttype() const {
  return static_cast< Diadoc::Api::Proto::Events::AttachmentType >(attachmenttype_);
}
inline void Entity::set_attachmenttype(Diadoc::Api::Proto::Events::AttachmentType value) {
  GOOGLE_DCHECK(Diadoc::Api::Proto::Events::AttachmentType_IsValid(value));
  set_has_attachmenttype();
  attachmenttype_ = value;
}

// optional string FileName = 6;
inline bool Entity::has_filename() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Entity::set_has_filename() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Entity::clear_has_filename() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Entity::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& Entity::filename() const {
  return *filename_;
}
inline void Entity::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void Entity::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void Entity::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Entity::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* Entity::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool NeedRecipientSignature = 7 [default = false];
inline bool Entity::has_needrecipientsignature() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Entity::set_has_needrecipientsignature() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Entity::clear_has_needrecipientsignature() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Entity::clear_needrecipientsignature() {
  needrecipientsignature_ = false;
  clear_has_needrecipientsignature();
}
inline bool Entity::needrecipientsignature() const {
  return needrecipientsignature_;
}
inline void Entity::set_needrecipientsignature(bool value) {
  set_has_needrecipientsignature();
  needrecipientsignature_ = value;
}

// optional string SignerBoxId = 8;
inline bool Entity::has_signerboxid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Entity::set_has_signerboxid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Entity::clear_has_signerboxid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Entity::clear_signerboxid() {
  if (signerboxid_ != &::google::protobuf::internal::kEmptyString) {
    signerboxid_->clear();
  }
  clear_has_signerboxid();
}
inline const ::std::string& Entity::signerboxid() const {
  return *signerboxid_;
}
inline void Entity::set_signerboxid(const ::std::string& value) {
  set_has_signerboxid();
  if (signerboxid_ == &::google::protobuf::internal::kEmptyString) {
    signerboxid_ = new ::std::string;
  }
  signerboxid_->assign(value);
}
inline void Entity::set_signerboxid(const char* value) {
  set_has_signerboxid();
  if (signerboxid_ == &::google::protobuf::internal::kEmptyString) {
    signerboxid_ = new ::std::string;
  }
  signerboxid_->assign(value);
}
inline void Entity::set_signerboxid(const char* value, size_t size) {
  set_has_signerboxid();
  if (signerboxid_ == &::google::protobuf::internal::kEmptyString) {
    signerboxid_ = new ::std::string;
  }
  signerboxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Entity::mutable_signerboxid() {
  set_has_signerboxid();
  if (signerboxid_ == &::google::protobuf::internal::kEmptyString) {
    signerboxid_ = new ::std::string;
  }
  return signerboxid_;
}
inline ::std::string* Entity::release_signerboxid() {
  clear_has_signerboxid();
  if (signerboxid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signerboxid_;
    signerboxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string NotDeliveredEventId = 10;
inline bool Entity::has_notdeliveredeventid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Entity::set_has_notdeliveredeventid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Entity::clear_has_notdeliveredeventid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Entity::clear_notdeliveredeventid() {
  if (notdeliveredeventid_ != &::google::protobuf::internal::kEmptyString) {
    notdeliveredeventid_->clear();
  }
  clear_has_notdeliveredeventid();
}
inline const ::std::string& Entity::notdeliveredeventid() const {
  return *notdeliveredeventid_;
}
inline void Entity::set_notdeliveredeventid(const ::std::string& value) {
  set_has_notdeliveredeventid();
  if (notdeliveredeventid_ == &::google::protobuf::internal::kEmptyString) {
    notdeliveredeventid_ = new ::std::string;
  }
  notdeliveredeventid_->assign(value);
}
inline void Entity::set_notdeliveredeventid(const char* value) {
  set_has_notdeliveredeventid();
  if (notdeliveredeventid_ == &::google::protobuf::internal::kEmptyString) {
    notdeliveredeventid_ = new ::std::string;
  }
  notdeliveredeventid_->assign(value);
}
inline void Entity::set_notdeliveredeventid(const char* value, size_t size) {
  set_has_notdeliveredeventid();
  if (notdeliveredeventid_ == &::google::protobuf::internal::kEmptyString) {
    notdeliveredeventid_ = new ::std::string;
  }
  notdeliveredeventid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Entity::mutable_notdeliveredeventid() {
  set_has_notdeliveredeventid();
  if (notdeliveredeventid_ == &::google::protobuf::internal::kEmptyString) {
    notdeliveredeventid_ = new ::std::string;
  }
  return notdeliveredeventid_;
}
inline ::std::string* Entity::release_notdeliveredeventid() {
  clear_has_notdeliveredeventid();
  if (notdeliveredeventid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notdeliveredeventid_;
    notdeliveredeventid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .Diadoc.Api.Proto.Documents.Document DocumentInfo = 11;
inline bool Entity::has_documentinfo() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Entity::set_has_documentinfo() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Entity::clear_has_documentinfo() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Entity::clear_documentinfo() {
  if (documentinfo_ != NULL) documentinfo_->::Diadoc::Api::Proto::Documents::Document::Clear();
  clear_has_documentinfo();
}
inline const ::Diadoc::Api::Proto::Documents::Document& Entity::documentinfo() const {
  return documentinfo_ != NULL ? *documentinfo_ : *default_instance_->documentinfo_;
}
inline ::Diadoc::Api::Proto::Documents::Document* Entity::mutable_documentinfo() {
  set_has_documentinfo();
  if (documentinfo_ == NULL) documentinfo_ = new ::Diadoc::Api::Proto::Documents::Document;
  return documentinfo_;
}
inline ::Diadoc::Api::Proto::Documents::Document* Entity::release_documentinfo() {
  clear_has_documentinfo();
  ::Diadoc::Api::Proto::Documents::Document* temp = documentinfo_;
  documentinfo_ = NULL;
  return temp;
}

// optional sfixed64 RawCreationDate = 12 [default = 0];
inline bool Entity::has_rawcreationdate() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Entity::set_has_rawcreationdate() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Entity::clear_has_rawcreationdate() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Entity::clear_rawcreationdate() {
  rawcreationdate_ = GOOGLE_LONGLONG(0);
  clear_has_rawcreationdate();
}
inline ::google::protobuf::int64 Entity::rawcreationdate() const {
  return rawcreationdate_;
}
inline void Entity::set_rawcreationdate(::google::protobuf::int64 value) {
  set_has_rawcreationdate();
  rawcreationdate_ = value;
}

// optional .Diadoc.Api.Proto.Events.ResolutionInfo ResolutionInfo = 13;
inline bool Entity::has_resolutioninfo() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Entity::set_has_resolutioninfo() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Entity::clear_has_resolutioninfo() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Entity::clear_resolutioninfo() {
  if (resolutioninfo_ != NULL) resolutioninfo_->::Diadoc::Api::Proto::Events::ResolutionInfo::Clear();
  clear_has_resolutioninfo();
}
inline const ::Diadoc::Api::Proto::Events::ResolutionInfo& Entity::resolutioninfo() const {
  return resolutioninfo_ != NULL ? *resolutioninfo_ : *default_instance_->resolutioninfo_;
}
inline ::Diadoc::Api::Proto::Events::ResolutionInfo* Entity::mutable_resolutioninfo() {
  set_has_resolutioninfo();
  if (resolutioninfo_ == NULL) resolutioninfo_ = new ::Diadoc::Api::Proto::Events::ResolutionInfo;
  return resolutioninfo_;
}
inline ::Diadoc::Api::Proto::Events::ResolutionInfo* Entity::release_resolutioninfo() {
  clear_has_resolutioninfo();
  ::Diadoc::Api::Proto::Events::ResolutionInfo* temp = resolutioninfo_;
  resolutioninfo_ = NULL;
  return temp;
}

// optional string SignerDepartmentId = 14;
inline bool Entity::has_signerdepartmentid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Entity::set_has_signerdepartmentid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Entity::clear_has_signerdepartmentid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Entity::clear_signerdepartmentid() {
  if (signerdepartmentid_ != &::google::protobuf::internal::kEmptyString) {
    signerdepartmentid_->clear();
  }
  clear_has_signerdepartmentid();
}
inline const ::std::string& Entity::signerdepartmentid() const {
  return *signerdepartmentid_;
}
inline void Entity::set_signerdepartmentid(const ::std::string& value) {
  set_has_signerdepartmentid();
  if (signerdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    signerdepartmentid_ = new ::std::string;
  }
  signerdepartmentid_->assign(value);
}
inline void Entity::set_signerdepartmentid(const char* value) {
  set_has_signerdepartmentid();
  if (signerdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    signerdepartmentid_ = new ::std::string;
  }
  signerdepartmentid_->assign(value);
}
inline void Entity::set_signerdepartmentid(const char* value, size_t size) {
  set_has_signerdepartmentid();
  if (signerdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    signerdepartmentid_ = new ::std::string;
  }
  signerdepartmentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Entity::mutable_signerdepartmentid() {
  set_has_signerdepartmentid();
  if (signerdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    signerdepartmentid_ = new ::std::string;
  }
  return signerdepartmentid_;
}
inline ::std::string* Entity::release_signerdepartmentid() {
  clear_has_signerdepartmentid();
  if (signerdepartmentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signerdepartmentid_;
    signerdepartmentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .Diadoc.Api.Proto.Events.ResolutionRequestInfo ResolutionRequestInfo = 15;
inline bool Entity::has_resolutionrequestinfo() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Entity::set_has_resolutionrequestinfo() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Entity::clear_has_resolutionrequestinfo() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Entity::clear_resolutionrequestinfo() {
  if (resolutionrequestinfo_ != NULL) resolutionrequestinfo_->::Diadoc::Api::Proto::Events::ResolutionRequestInfo::Clear();
  clear_has_resolutionrequestinfo();
}
inline const ::Diadoc::Api::Proto::Events::ResolutionRequestInfo& Entity::resolutionrequestinfo() const {
  return resolutionrequestinfo_ != NULL ? *resolutionrequestinfo_ : *default_instance_->resolutionrequestinfo_;
}
inline ::Diadoc::Api::Proto::Events::ResolutionRequestInfo* Entity::mutable_resolutionrequestinfo() {
  set_has_resolutionrequestinfo();
  if (resolutionrequestinfo_ == NULL) resolutionrequestinfo_ = new ::Diadoc::Api::Proto::Events::ResolutionRequestInfo;
  return resolutionrequestinfo_;
}
inline ::Diadoc::Api::Proto::Events::ResolutionRequestInfo* Entity::release_resolutionrequestinfo() {
  clear_has_resolutionrequestinfo();
  ::Diadoc::Api::Proto::Events::ResolutionRequestInfo* temp = resolutionrequestinfo_;
  resolutionrequestinfo_ = NULL;
  return temp;
}

// optional .Diadoc.Api.Proto.Events.ResolutionRequestDenialInfo ResolutionRequestDenialInfo = 16;
inline bool Entity::has_resolutionrequestdenialinfo() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Entity::set_has_resolutionrequestdenialinfo() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Entity::clear_has_resolutionrequestdenialinfo() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Entity::clear_resolutionrequestdenialinfo() {
  if (resolutionrequestdenialinfo_ != NULL) resolutionrequestdenialinfo_->::Diadoc::Api::Proto::Events::ResolutionRequestDenialInfo::Clear();
  clear_has_resolutionrequestdenialinfo();
}
inline const ::Diadoc::Api::Proto::Events::ResolutionRequestDenialInfo& Entity::resolutionrequestdenialinfo() const {
  return resolutionrequestdenialinfo_ != NULL ? *resolutionrequestdenialinfo_ : *default_instance_->resolutionrequestdenialinfo_;
}
inline ::Diadoc::Api::Proto::Events::ResolutionRequestDenialInfo* Entity::mutable_resolutionrequestdenialinfo() {
  set_has_resolutionrequestdenialinfo();
  if (resolutionrequestdenialinfo_ == NULL) resolutionrequestdenialinfo_ = new ::Diadoc::Api::Proto::Events::ResolutionRequestDenialInfo;
  return resolutionrequestdenialinfo_;
}
inline ::Diadoc::Api::Proto::Events::ResolutionRequestDenialInfo* Entity::release_resolutionrequestdenialinfo() {
  clear_has_resolutionrequestdenialinfo();
  ::Diadoc::Api::Proto::Events::ResolutionRequestDenialInfo* temp = resolutionrequestdenialinfo_;
  resolutionrequestdenialinfo_ = NULL;
  return temp;
}

// optional bool NeedReceipt = 17 [default = false];
inline bool Entity::has_needreceipt() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Entity::set_has_needreceipt() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Entity::clear_has_needreceipt() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Entity::clear_needreceipt() {
  needreceipt_ = false;
  clear_has_needreceipt();
}
inline bool Entity::needreceipt() const {
  return needreceipt_;
}
inline void Entity::set_needreceipt(bool value) {
  set_has_needreceipt();
  needreceipt_ = value;
}

// optional string PacketId = 18;
inline bool Entity::has_packetid() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Entity::set_has_packetid() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Entity::clear_has_packetid() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Entity::clear_packetid() {
  if (packetid_ != &::google::protobuf::internal::kEmptyString) {
    packetid_->clear();
  }
  clear_has_packetid();
}
inline const ::std::string& Entity::packetid() const {
  return *packetid_;
}
inline void Entity::set_packetid(const ::std::string& value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
}
inline void Entity::set_packetid(const char* value) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(value);
}
inline void Entity::set_packetid(const char* value, size_t size) {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  packetid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Entity::mutable_packetid() {
  set_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    packetid_ = new ::std::string;
  }
  return packetid_;
}
inline ::std::string* Entity::release_packetid() {
  clear_has_packetid();
  if (packetid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packetid_;
    packetid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool IsApprovementSignature = 19 [default = false];
inline bool Entity::has_isapprovementsignature() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Entity::set_has_isapprovementsignature() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Entity::clear_has_isapprovementsignature() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Entity::clear_isapprovementsignature() {
  isapprovementsignature_ = false;
  clear_has_isapprovementsignature();
}
inline bool Entity::isapprovementsignature() const {
  return isapprovementsignature_;
}
inline void Entity::set_isapprovementsignature(bool value) {
  set_has_isapprovementsignature();
  isapprovementsignature_ = value;
}

// optional bool IsEncryptedContent = 20 [default = false];
inline bool Entity::has_isencryptedcontent() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Entity::set_has_isencryptedcontent() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Entity::clear_has_isencryptedcontent() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Entity::clear_isencryptedcontent() {
  isencryptedcontent_ = false;
  clear_has_isencryptedcontent();
}
inline bool Entity::isencryptedcontent() const {
  return isencryptedcontent_;
}
inline void Entity::set_isencryptedcontent(bool value) {
  set_has_isencryptedcontent();
  isencryptedcontent_ = value;
}

// -------------------------------------------------------------------

// EntityPatch

// required string EntityId = 1;
inline bool EntityPatch::has_entityid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntityPatch::set_has_entityid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntityPatch::clear_has_entityid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntityPatch::clear_entityid() {
  if (entityid_ != &::google::protobuf::internal::kEmptyString) {
    entityid_->clear();
  }
  clear_has_entityid();
}
inline const ::std::string& EntityPatch::entityid() const {
  return *entityid_;
}
inline void EntityPatch::set_entityid(const ::std::string& value) {
  set_has_entityid();
  if (entityid_ == &::google::protobuf::internal::kEmptyString) {
    entityid_ = new ::std::string;
  }
  entityid_->assign(value);
}
inline void EntityPatch::set_entityid(const char* value) {
  set_has_entityid();
  if (entityid_ == &::google::protobuf::internal::kEmptyString) {
    entityid_ = new ::std::string;
  }
  entityid_->assign(value);
}
inline void EntityPatch::set_entityid(const char* value, size_t size) {
  set_has_entityid();
  if (entityid_ == &::google::protobuf::internal::kEmptyString) {
    entityid_ = new ::std::string;
  }
  entityid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EntityPatch::mutable_entityid() {
  set_has_entityid();
  if (entityid_ == &::google::protobuf::internal::kEmptyString) {
    entityid_ = new ::std::string;
  }
  return entityid_;
}
inline ::std::string* EntityPatch::release_entityid() {
  clear_has_entityid();
  if (entityid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entityid_;
    entityid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool DocumentIsDeleted = 2 [default = false];
inline bool EntityPatch::has_documentisdeleted() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EntityPatch::set_has_documentisdeleted() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EntityPatch::clear_has_documentisdeleted() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EntityPatch::clear_documentisdeleted() {
  documentisdeleted_ = false;
  clear_has_documentisdeleted();
}
inline bool EntityPatch::documentisdeleted() const {
  return documentisdeleted_;
}
inline void EntityPatch::set_documentisdeleted(bool value) {
  set_has_documentisdeleted();
  documentisdeleted_ = value;
}

// optional string MovedToDepartment = 3;
inline bool EntityPatch::has_movedtodepartment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EntityPatch::set_has_movedtodepartment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EntityPatch::clear_has_movedtodepartment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EntityPatch::clear_movedtodepartment() {
  if (movedtodepartment_ != &::google::protobuf::internal::kEmptyString) {
    movedtodepartment_->clear();
  }
  clear_has_movedtodepartment();
}
inline const ::std::string& EntityPatch::movedtodepartment() const {
  return *movedtodepartment_;
}
inline void EntityPatch::set_movedtodepartment(const ::std::string& value) {
  set_has_movedtodepartment();
  if (movedtodepartment_ == &::google::protobuf::internal::kEmptyString) {
    movedtodepartment_ = new ::std::string;
  }
  movedtodepartment_->assign(value);
}
inline void EntityPatch::set_movedtodepartment(const char* value) {
  set_has_movedtodepartment();
  if (movedtodepartment_ == &::google::protobuf::internal::kEmptyString) {
    movedtodepartment_ = new ::std::string;
  }
  movedtodepartment_->assign(value);
}
inline void EntityPatch::set_movedtodepartment(const char* value, size_t size) {
  set_has_movedtodepartment();
  if (movedtodepartment_ == &::google::protobuf::internal::kEmptyString) {
    movedtodepartment_ = new ::std::string;
  }
  movedtodepartment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EntityPatch::mutable_movedtodepartment() {
  set_has_movedtodepartment();
  if (movedtodepartment_ == &::google::protobuf::internal::kEmptyString) {
    movedtodepartment_ = new ::std::string;
  }
  return movedtodepartment_;
}
inline ::std::string* EntityPatch::release_movedtodepartment() {
  clear_has_movedtodepartment();
  if (movedtodepartment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = movedtodepartment_;
    movedtodepartment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool DocumentIsRestored = 4 [default = false];
inline bool EntityPatch::has_documentisrestored() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EntityPatch::set_has_documentisrestored() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EntityPatch::clear_has_documentisrestored() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EntityPatch::clear_documentisrestored() {
  documentisrestored_ = false;
  clear_has_documentisrestored();
}
inline bool EntityPatch::documentisrestored() const {
  return documentisrestored_;
}
inline void EntityPatch::set_documentisrestored(bool value) {
  set_has_documentisrestored();
  documentisrestored_ = value;
}

// optional bool ContentIsPatched = 5 [default = false];
inline bool EntityPatch::has_contentispatched() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EntityPatch::set_has_contentispatched() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EntityPatch::clear_has_contentispatched() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EntityPatch::clear_contentispatched() {
  contentispatched_ = false;
  clear_has_contentispatched();
}
inline bool EntityPatch::contentispatched() const {
  return contentispatched_;
}
inline void EntityPatch::set_contentispatched(bool value) {
  set_has_contentispatched();
  contentispatched_ = value;
}

// optional string ForwardedToBoxId = 6;
inline bool EntityPatch::has_forwardedtoboxid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EntityPatch::set_has_forwardedtoboxid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EntityPatch::clear_has_forwardedtoboxid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EntityPatch::clear_forwardedtoboxid() {
  if (forwardedtoboxid_ != &::google::protobuf::internal::kEmptyString) {
    forwardedtoboxid_->clear();
  }
  clear_has_forwardedtoboxid();
}
inline const ::std::string& EntityPatch::forwardedtoboxid() const {
  return *forwardedtoboxid_;
}
inline void EntityPatch::set_forwardedtoboxid(const ::std::string& value) {
  set_has_forwardedtoboxid();
  if (forwardedtoboxid_ == &::google::protobuf::internal::kEmptyString) {
    forwardedtoboxid_ = new ::std::string;
  }
  forwardedtoboxid_->assign(value);
}
inline void EntityPatch::set_forwardedtoboxid(const char* value) {
  set_has_forwardedtoboxid();
  if (forwardedtoboxid_ == &::google::protobuf::internal::kEmptyString) {
    forwardedtoboxid_ = new ::std::string;
  }
  forwardedtoboxid_->assign(value);
}
inline void EntityPatch::set_forwardedtoboxid(const char* value, size_t size) {
  set_has_forwardedtoboxid();
  if (forwardedtoboxid_ == &::google::protobuf::internal::kEmptyString) {
    forwardedtoboxid_ = new ::std::string;
  }
  forwardedtoboxid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EntityPatch::mutable_forwardedtoboxid() {
  set_has_forwardedtoboxid();
  if (forwardedtoboxid_ == &::google::protobuf::internal::kEmptyString) {
    forwardedtoboxid_ = new ::std::string;
  }
  return forwardedtoboxid_;
}
inline ::std::string* EntityPatch::release_forwardedtoboxid() {
  clear_has_forwardedtoboxid();
  if (forwardedtoboxid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = forwardedtoboxid_;
    forwardedtoboxid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Events
}  // namespace Proto
}  // namespace Api
}  // namespace Diadoc

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< Diadoc::Api::Proto::Events::EntityType>() {
  return Diadoc::Api::Proto::Events::EntityType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< Diadoc::Api::Proto::Events::AttachmentType>() {
  return Diadoc::Api::Proto::Events::AttachmentType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Events_2fDiadocMessage_2eGetApi_2eproto__INCLUDED

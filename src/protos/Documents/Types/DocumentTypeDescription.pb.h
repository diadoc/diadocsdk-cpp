// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Documents/Types/DocumentTypeDescription.proto

#ifndef PROTOBUF_Documents_2fTypes_2fDocumentTypeDescription_2eproto__INCLUDED
#define PROTOBUF_Documents_2fTypes_2fDocumentTypeDescription_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Invoicing/ExtendedSigner.pb.h"
// @@protoc_insertion_point(includes)

namespace Diadoc {
namespace Api {
namespace Proto {
namespace Documents {
namespace Types {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Documents_2fTypes_2fDocumentTypeDescription_2eproto();
void protobuf_AssignDesc_Documents_2fTypes_2fDocumentTypeDescription_2eproto();
void protobuf_ShutdownFile_Documents_2fTypes_2fDocumentTypeDescription_2eproto();

class DocumentTypeDescription;
class GetDocumentTypesResponse;
class DocumentFunction;
class DocumentVersion;
class DocumentWorkflow;
class DocumentTitle;
class SignerInfo;
class DocumentMetadataItem;
class DetectedDocumentType;
class DetectDocumentTypesResponse;

enum DocumentDocflow {
  External = 0,
  Internal = 1
};
bool DocumentDocflow_IsValid(int value);
const DocumentDocflow DocumentDocflow_MIN = External;
const DocumentDocflow DocumentDocflow_MAX = Internal;
const int DocumentDocflow_ARRAYSIZE = DocumentDocflow_MAX + 1;

const ::google::protobuf::EnumDescriptor* DocumentDocflow_descriptor();
inline const ::std::string& DocumentDocflow_Name(DocumentDocflow value) {
  return ::google::protobuf::internal::NameOfEnum(
    DocumentDocflow_descriptor(), value);
}
inline bool DocumentDocflow_Parse(
    const ::std::string& name, DocumentDocflow* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DocumentDocflow>(
    DocumentDocflow_descriptor(), name, value);
}
enum SignerType {
  None = 0,
  Signer = 1,
  ExtendedSigner = 2
};
bool SignerType_IsValid(int value);
const SignerType SignerType_MIN = None;
const SignerType SignerType_MAX = ExtendedSigner;
const int SignerType_ARRAYSIZE = SignerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SignerType_descriptor();
inline const ::std::string& SignerType_Name(SignerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SignerType_descriptor(), value);
}
inline bool SignerType_Parse(
    const ::std::string& name, SignerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignerType>(
    SignerType_descriptor(), name, value);
}
enum DocumentMetadataItemType {
  String = 0,
  Integer = 1,
  Decimal = 2,
  Date = 3,
  Time = 4
};
bool DocumentMetadataItemType_IsValid(int value);
const DocumentMetadataItemType DocumentMetadataItemType_MIN = String;
const DocumentMetadataItemType DocumentMetadataItemType_MAX = Time;
const int DocumentMetadataItemType_ARRAYSIZE = DocumentMetadataItemType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DocumentMetadataItemType_descriptor();
inline const ::std::string& DocumentMetadataItemType_Name(DocumentMetadataItemType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DocumentMetadataItemType_descriptor(), value);
}
inline bool DocumentMetadataItemType_Parse(
    const ::std::string& name, DocumentMetadataItemType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DocumentMetadataItemType>(
    DocumentMetadataItemType_descriptor(), name, value);
}
enum DocumentMetadataSource {
  Xml = 0,
  User = 1
};
bool DocumentMetadataSource_IsValid(int value);
const DocumentMetadataSource DocumentMetadataSource_MIN = Xml;
const DocumentMetadataSource DocumentMetadataSource_MAX = User;
const int DocumentMetadataSource_ARRAYSIZE = DocumentMetadataSource_MAX + 1;

const ::google::protobuf::EnumDescriptor* DocumentMetadataSource_descriptor();
inline const ::std::string& DocumentMetadataSource_Name(DocumentMetadataSource value) {
  return ::google::protobuf::internal::NameOfEnum(
    DocumentMetadataSource_descriptor(), value);
}
inline bool DocumentMetadataSource_Parse(
    const ::std::string& name, DocumentMetadataSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DocumentMetadataSource>(
    DocumentMetadataSource_descriptor(), name, value);
}
// ===================================================================

class DocumentTypeDescription : public ::google::protobuf::Message {
 public:
  DocumentTypeDescription();
  virtual ~DocumentTypeDescription();

  DocumentTypeDescription(const DocumentTypeDescription& from);

  inline DocumentTypeDescription& operator=(const DocumentTypeDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DocumentTypeDescription& default_instance();

  void Swap(DocumentTypeDescription* other);

  // implements Message ----------------------------------------------

  DocumentTypeDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocumentTypeDescription& from);
  void MergeFrom(const DocumentTypeDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string Title = 2;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 2;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // repeated .Diadoc.Api.Proto.Documents.Types.DocumentDocflow SupportedDocflows = 3;
  inline int supporteddocflows_size() const;
  inline void clear_supporteddocflows();
  static const int kSupportedDocflowsFieldNumber = 3;
  inline ::Diadoc::Api::Proto::Documents::Types::DocumentDocflow supporteddocflows(int index) const;
  inline void set_supporteddocflows(int index, ::Diadoc::Api::Proto::Documents::Types::DocumentDocflow value);
  inline void add_supporteddocflows(::Diadoc::Api::Proto::Documents::Types::DocumentDocflow value);
  inline const ::google::protobuf::RepeatedField<int>& supporteddocflows() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_supporteddocflows();

  // required bool RequiresFnsRegistration = 4;
  inline bool has_requiresfnsregistration() const;
  inline void clear_requiresfnsregistration();
  static const int kRequiresFnsRegistrationFieldNumber = 4;
  inline bool requiresfnsregistration() const;
  inline void set_requiresfnsregistration(bool value);

  // repeated .Diadoc.Api.Proto.Documents.Types.DocumentFunction Functions = 9;
  inline int functions_size() const;
  inline void clear_functions();
  static const int kFunctionsFieldNumber = 9;
  inline const ::Diadoc::Api::Proto::Documents::Types::DocumentFunction& functions(int index) const;
  inline ::Diadoc::Api::Proto::Documents::Types::DocumentFunction* mutable_functions(int index);
  inline ::Diadoc::Api::Proto::Documents::Types::DocumentFunction* add_functions();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentFunction >&
      functions() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentFunction >*
      mutable_functions();

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_requiresfnsregistration();
  inline void clear_has_requiresfnsregistration();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* title_;
  ::google::protobuf::RepeatedField<int> supporteddocflows_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentFunction > functions_;
  bool requiresfnsregistration_;
  friend void  protobuf_AddDesc_Documents_2fTypes_2fDocumentTypeDescription_2eproto();
  friend void protobuf_AssignDesc_Documents_2fTypes_2fDocumentTypeDescription_2eproto();
  friend void protobuf_ShutdownFile_Documents_2fTypes_2fDocumentTypeDescription_2eproto();

  void InitAsDefaultInstance();
  static DocumentTypeDescription* default_instance_;
};
// -------------------------------------------------------------------

class GetDocumentTypesResponse : public ::google::protobuf::Message {
 public:
  GetDocumentTypesResponse();
  virtual ~GetDocumentTypesResponse();

  GetDocumentTypesResponse(const GetDocumentTypesResponse& from);

  inline GetDocumentTypesResponse& operator=(const GetDocumentTypesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDocumentTypesResponse& default_instance();

  void Swap(GetDocumentTypesResponse* other);

  // implements Message ----------------------------------------------

  GetDocumentTypesResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetDocumentTypesResponse& from);
  void MergeFrom(const GetDocumentTypesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription DocumentTypes = 1;
  inline int documenttypes_size() const;
  inline void clear_documenttypes();
  static const int kDocumentTypesFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Documents::Types::DocumentTypeDescription& documenttypes(int index) const;
  inline ::Diadoc::Api::Proto::Documents::Types::DocumentTypeDescription* mutable_documenttypes(int index);
  inline ::Diadoc::Api::Proto::Documents::Types::DocumentTypeDescription* add_documenttypes();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentTypeDescription >&
      documenttypes() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentTypeDescription >*
      mutable_documenttypes();

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Documents.Types.GetDocumentTypesResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentTypeDescription > documenttypes_;
  friend void  protobuf_AddDesc_Documents_2fTypes_2fDocumentTypeDescription_2eproto();
  friend void protobuf_AssignDesc_Documents_2fTypes_2fDocumentTypeDescription_2eproto();
  friend void protobuf_ShutdownFile_Documents_2fTypes_2fDocumentTypeDescription_2eproto();

  void InitAsDefaultInstance();
  static GetDocumentTypesResponse* default_instance_;
};
// -------------------------------------------------------------------

class DocumentFunction : public ::google::protobuf::Message {
 public:
  DocumentFunction();
  virtual ~DocumentFunction();

  DocumentFunction(const DocumentFunction& from);

  inline DocumentFunction& operator=(const DocumentFunction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DocumentFunction& default_instance();

  void Swap(DocumentFunction* other);

  // implements Message ----------------------------------------------

  DocumentFunction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocumentFunction& from);
  void MergeFrom(const DocumentFunction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .Diadoc.Api.Proto.Documents.Types.DocumentVersion Versions = 2;
  inline int versions_size() const;
  inline void clear_versions();
  static const int kVersionsFieldNumber = 2;
  inline const ::Diadoc::Api::Proto::Documents::Types::DocumentVersion& versions(int index) const;
  inline ::Diadoc::Api::Proto::Documents::Types::DocumentVersion* mutable_versions(int index);
  inline ::Diadoc::Api::Proto::Documents::Types::DocumentVersion* add_versions();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentVersion >&
      versions() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentVersion >*
      mutable_versions();

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Documents.Types.DocumentFunction)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentVersion > versions_;
  friend void  protobuf_AddDesc_Documents_2fTypes_2fDocumentTypeDescription_2eproto();
  friend void protobuf_AssignDesc_Documents_2fTypes_2fDocumentTypeDescription_2eproto();
  friend void protobuf_ShutdownFile_Documents_2fTypes_2fDocumentTypeDescription_2eproto();

  void InitAsDefaultInstance();
  static DocumentFunction* default_instance_;
};
// -------------------------------------------------------------------

class DocumentVersion : public ::google::protobuf::Message {
 public:
  DocumentVersion();
  virtual ~DocumentVersion();

  DocumentVersion(const DocumentVersion& from);

  inline DocumentVersion& operator=(const DocumentVersion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DocumentVersion& default_instance();

  void Swap(DocumentVersion* other);

  // implements Message ----------------------------------------------

  DocumentVersion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocumentVersion& from);
  void MergeFrom(const DocumentVersion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // required bool SupportsContentPatching = 2;
  inline bool has_supportscontentpatching() const;
  inline void clear_supportscontentpatching();
  static const int kSupportsContentPatchingFieldNumber = 2;
  inline bool supportscontentpatching() const;
  inline void set_supportscontentpatching(bool value);

  // required bool SupportsEncrypting = 3;
  inline bool has_supportsencrypting() const;
  inline void clear_supportsencrypting();
  static const int kSupportsEncryptingFieldNumber = 3;
  inline bool supportsencrypting() const;
  inline void set_supportsencrypting(bool value);

  // repeated .Diadoc.Api.Proto.Documents.Types.DocumentTitle Titles = 4;
  inline int titles_size() const;
  inline void clear_titles();
  static const int kTitlesFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::Documents::Types::DocumentTitle& titles(int index) const;
  inline ::Diadoc::Api::Proto::Documents::Types::DocumentTitle* mutable_titles(int index);
  inline ::Diadoc::Api::Proto::Documents::Types::DocumentTitle* add_titles();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentTitle >&
      titles() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentTitle >*
      mutable_titles();

  // required bool IsActual = 5;
  inline bool has_isactual() const;
  inline void clear_isactual();
  static const int kIsActualFieldNumber = 5;
  inline bool isactual() const;
  inline void set_isactual(bool value);

  // repeated .Diadoc.Api.Proto.Documents.Types.DocumentWorkflow Workflows = 6;
  inline int workflows_size() const;
  inline void clear_workflows();
  static const int kWorkflowsFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::Documents::Types::DocumentWorkflow& workflows(int index) const;
  inline ::Diadoc::Api::Proto::Documents::Types::DocumentWorkflow* mutable_workflows(int index);
  inline ::Diadoc::Api::Proto::Documents::Types::DocumentWorkflow* add_workflows();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentWorkflow >&
      workflows() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentWorkflow >*
      mutable_workflows();

  // required bool SupportsPredefinedRecipientTitle = 7;
  inline bool has_supportspredefinedrecipienttitle() const;
  inline void clear_supportspredefinedrecipienttitle();
  static const int kSupportsPredefinedRecipientTitleFieldNumber = 7;
  inline bool supportspredefinedrecipienttitle() const;
  inline void set_supportspredefinedrecipienttitle(bool value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Documents.Types.DocumentVersion)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_supportscontentpatching();
  inline void clear_has_supportscontentpatching();
  inline void set_has_supportsencrypting();
  inline void clear_has_supportsencrypting();
  inline void set_has_isactual();
  inline void clear_has_isactual();
  inline void set_has_supportspredefinedrecipienttitle();
  inline void clear_has_supportspredefinedrecipienttitle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* version_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentTitle > titles_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentWorkflow > workflows_;
  bool supportscontentpatching_;
  bool supportsencrypting_;
  bool isactual_;
  bool supportspredefinedrecipienttitle_;
  friend void  protobuf_AddDesc_Documents_2fTypes_2fDocumentTypeDescription_2eproto();
  friend void protobuf_AssignDesc_Documents_2fTypes_2fDocumentTypeDescription_2eproto();
  friend void protobuf_ShutdownFile_Documents_2fTypes_2fDocumentTypeDescription_2eproto();

  void InitAsDefaultInstance();
  static DocumentVersion* default_instance_;
};
// -------------------------------------------------------------------

class DocumentWorkflow : public ::google::protobuf::Message {
 public:
  DocumentWorkflow();
  virtual ~DocumentWorkflow();

  DocumentWorkflow(const DocumentWorkflow& from);

  inline DocumentWorkflow& operator=(const DocumentWorkflow& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DocumentWorkflow& default_instance();

  void Swap(DocumentWorkflow* other);

  // implements Message ----------------------------------------------

  DocumentWorkflow* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocumentWorkflow& from);
  void MergeFrom(const DocumentWorkflow& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required bool IsDefault = 2;
  inline bool has_isdefault() const;
  inline void clear_isdefault();
  static const int kIsDefaultFieldNumber = 2;
  inline bool isdefault() const;
  inline void set_isdefault(bool value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Documents.Types.DocumentWorkflow)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_isdefault();
  inline void clear_has_isdefault();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  bool isdefault_;
  friend void  protobuf_AddDesc_Documents_2fTypes_2fDocumentTypeDescription_2eproto();
  friend void protobuf_AssignDesc_Documents_2fTypes_2fDocumentTypeDescription_2eproto();
  friend void protobuf_ShutdownFile_Documents_2fTypes_2fDocumentTypeDescription_2eproto();

  void InitAsDefaultInstance();
  static DocumentWorkflow* default_instance_;
};
// -------------------------------------------------------------------

class DocumentTitle : public ::google::protobuf::Message {
 public:
  DocumentTitle();
  virtual ~DocumentTitle();

  DocumentTitle(const DocumentTitle& from);

  inline DocumentTitle& operator=(const DocumentTitle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DocumentTitle& default_instance();

  void Swap(DocumentTitle* other);

  // implements Message ----------------------------------------------

  DocumentTitle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocumentTitle& from);
  void MergeFrom(const DocumentTitle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Index = 7;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 7;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // required bool IsFormal = 1;
  inline bool has_isformal() const;
  inline void clear_isformal();
  static const int kIsFormalFieldNumber = 1;
  inline bool isformal() const;
  inline void set_isformal(bool value);

  // optional string XsdUrl = 2;
  inline bool has_xsdurl() const;
  inline void clear_xsdurl();
  static const int kXsdUrlFieldNumber = 2;
  inline const ::std::string& xsdurl() const;
  inline void set_xsdurl(const ::std::string& value);
  inline void set_xsdurl(const char* value);
  inline void set_xsdurl(const char* value, size_t size);
  inline ::std::string* mutable_xsdurl();
  inline ::std::string* release_xsdurl();
  inline void set_allocated_xsdurl(::std::string* xsdurl);

  // optional string UserDataXsdUrl = 5;
  inline bool has_userdataxsdurl() const;
  inline void clear_userdataxsdurl();
  static const int kUserDataXsdUrlFieldNumber = 5;
  inline const ::std::string& userdataxsdurl() const;
  inline void set_userdataxsdurl(const ::std::string& value);
  inline void set_userdataxsdurl(const char* value);
  inline void set_userdataxsdurl(const char* value, size_t size);
  inline ::std::string* mutable_userdataxsdurl();
  inline ::std::string* release_userdataxsdurl();
  inline void set_allocated_userdataxsdurl(::std::string* userdataxsdurl);

  // required .Diadoc.Api.Proto.Documents.Types.SignerInfo SignerInfo = 6;
  inline bool has_signerinfo() const;
  inline void clear_signerinfo();
  static const int kSignerInfoFieldNumber = 6;
  inline const ::Diadoc::Api::Proto::Documents::Types::SignerInfo& signerinfo() const;
  inline ::Diadoc::Api::Proto::Documents::Types::SignerInfo* mutable_signerinfo();
  inline ::Diadoc::Api::Proto::Documents::Types::SignerInfo* release_signerinfo();
  inline void set_allocated_signerinfo(::Diadoc::Api::Proto::Documents::Types::SignerInfo* signerinfo);

  // repeated .Diadoc.Api.Proto.Documents.Types.DocumentMetadataItem MetadataItems = 3;
  inline int metadataitems_size() const;
  inline void clear_metadataitems();
  static const int kMetadataItemsFieldNumber = 3;
  inline const ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItem& metadataitems(int index) const;
  inline ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItem* mutable_metadataitems(int index);
  inline ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItem* add_metadataitems();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItem >&
      metadataitems() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItem >*
      mutable_metadataitems();

  // repeated .Diadoc.Api.Proto.Documents.Types.DocumentMetadataItem EncryptedMetadataItems = 4;
  inline int encryptedmetadataitems_size() const;
  inline void clear_encryptedmetadataitems();
  static const int kEncryptedMetadataItemsFieldNumber = 4;
  inline const ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItem& encryptedmetadataitems(int index) const;
  inline ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItem* mutable_encryptedmetadataitems(int index);
  inline ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItem* add_encryptedmetadataitems();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItem >&
      encryptedmetadataitems() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItem >*
      mutable_encryptedmetadataitems();

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Documents.Types.DocumentTitle)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_isformal();
  inline void clear_has_isformal();
  inline void set_has_xsdurl();
  inline void clear_has_xsdurl();
  inline void set_has_userdataxsdurl();
  inline void clear_has_userdataxsdurl();
  inline void set_has_signerinfo();
  inline void clear_has_signerinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 index_;
  bool isformal_;
  ::std::string* xsdurl_;
  ::std::string* userdataxsdurl_;
  ::Diadoc::Api::Proto::Documents::Types::SignerInfo* signerinfo_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItem > metadataitems_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItem > encryptedmetadataitems_;
  friend void  protobuf_AddDesc_Documents_2fTypes_2fDocumentTypeDescription_2eproto();
  friend void protobuf_AssignDesc_Documents_2fTypes_2fDocumentTypeDescription_2eproto();
  friend void protobuf_ShutdownFile_Documents_2fTypes_2fDocumentTypeDescription_2eproto();

  void InitAsDefaultInstance();
  static DocumentTitle* default_instance_;
};
// -------------------------------------------------------------------

class SignerInfo : public ::google::protobuf::Message {
 public:
  SignerInfo();
  virtual ~SignerInfo();

  SignerInfo(const SignerInfo& from);

  inline SignerInfo& operator=(const SignerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignerInfo& default_instance();

  void Swap(SignerInfo* other);

  // implements Message ----------------------------------------------

  SignerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignerInfo& from);
  void MergeFrom(const SignerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Diadoc.Api.Proto.Documents.Types.SignerType SignerType = 1;
  inline bool has_signertype() const;
  inline void clear_signertype();
  static const int kSignerTypeFieldNumber = 1;
  inline ::Diadoc::Api::Proto::Documents::Types::SignerType signertype() const;
  inline void set_signertype(::Diadoc::Api::Proto::Documents::Types::SignerType value);

  // required .Diadoc.Api.Proto.Invoicing.Signers.DocumentTitleType ExtendedDocumentTitleType = 2 [default = Absent];
  inline bool has_extendeddocumenttitletype() const;
  inline void clear_extendeddocumenttitletype();
  static const int kExtendedDocumentTitleTypeFieldNumber = 2;
  inline ::Diadoc::Api::Proto::Invoicing::Signers::DocumentTitleType extendeddocumenttitletype() const;
  inline void set_extendeddocumenttitletype(::Diadoc::Api::Proto::Invoicing::Signers::DocumentTitleType value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Documents.Types.SignerInfo)
 private:
  inline void set_has_signertype();
  inline void clear_has_signertype();
  inline void set_has_extendeddocumenttitletype();
  inline void clear_has_extendeddocumenttitletype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int signertype_;
  int extendeddocumenttitletype_;
  friend void  protobuf_AddDesc_Documents_2fTypes_2fDocumentTypeDescription_2eproto();
  friend void protobuf_AssignDesc_Documents_2fTypes_2fDocumentTypeDescription_2eproto();
  friend void protobuf_ShutdownFile_Documents_2fTypes_2fDocumentTypeDescription_2eproto();

  void InitAsDefaultInstance();
  static SignerInfo* default_instance_;
};
// -------------------------------------------------------------------

class DocumentMetadataItem : public ::google::protobuf::Message {
 public:
  DocumentMetadataItem();
  virtual ~DocumentMetadataItem();

  DocumentMetadataItem(const DocumentMetadataItem& from);

  inline DocumentMetadataItem& operator=(const DocumentMetadataItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DocumentMetadataItem& default_instance();

  void Swap(DocumentMetadataItem* other);

  // implements Message ----------------------------------------------

  DocumentMetadataItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DocumentMetadataItem& from);
  void MergeFrom(const DocumentMetadataItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required .Diadoc.Api.Proto.Documents.Types.DocumentMetadataItemType Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItemType type() const;
  inline void set_type(::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItemType value);

  // required bool IsRequired = 3;
  inline bool has_isrequired() const;
  inline void clear_isrequired();
  static const int kIsRequiredFieldNumber = 3;
  inline bool isrequired() const;
  inline void set_isrequired(bool value);

  // required .Diadoc.Api.Proto.Documents.Types.DocumentMetadataSource Source = 4;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 4;
  inline ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataSource source() const;
  inline void set_source(::Diadoc::Api::Proto::Documents::Types::DocumentMetadataSource value);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Documents.Types.DocumentMetadataItem)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_isrequired();
  inline void clear_has_isrequired();
  inline void set_has_source();
  inline void clear_has_source();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  int type_;
  bool isrequired_;
  int source_;
  friend void  protobuf_AddDesc_Documents_2fTypes_2fDocumentTypeDescription_2eproto();
  friend void protobuf_AssignDesc_Documents_2fTypes_2fDocumentTypeDescription_2eproto();
  friend void protobuf_ShutdownFile_Documents_2fTypes_2fDocumentTypeDescription_2eproto();

  void InitAsDefaultInstance();
  static DocumentMetadataItem* default_instance_;
};
// -------------------------------------------------------------------

class DetectedDocumentType : public ::google::protobuf::Message {
 public:
  DetectedDocumentType();
  virtual ~DetectedDocumentType();

  DetectedDocumentType(const DetectedDocumentType& from);

  inline DetectedDocumentType& operator=(const DetectedDocumentType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DetectedDocumentType& default_instance();

  void Swap(DetectedDocumentType* other);

  // implements Message ----------------------------------------------

  DetectedDocumentType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DetectedDocumentType& from);
  void MergeFrom(const DetectedDocumentType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string TypeNamedId = 1;
  inline bool has_typenamedid() const;
  inline void clear_typenamedid();
  static const int kTypeNamedIdFieldNumber = 1;
  inline const ::std::string& typenamedid() const;
  inline void set_typenamedid(const ::std::string& value);
  inline void set_typenamedid(const char* value);
  inline void set_typenamedid(const char* value, size_t size);
  inline ::std::string* mutable_typenamedid();
  inline ::std::string* release_typenamedid();
  inline void set_allocated_typenamedid(::std::string* typenamedid);

  // required string Function = 2;
  inline bool has_function() const;
  inline void clear_function();
  static const int kFunctionFieldNumber = 2;
  inline const ::std::string& function() const;
  inline void set_function(const ::std::string& value);
  inline void set_function(const char* value);
  inline void set_function(const char* value, size_t size);
  inline ::std::string* mutable_function();
  inline ::std::string* release_function();
  inline void set_allocated_function(::std::string* function);

  // required string Version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Documents.Types.DetectedDocumentType)
 private:
  inline void set_has_typenamedid();
  inline void clear_has_typenamedid();
  inline void set_has_function();
  inline void clear_has_function();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* typenamedid_;
  ::std::string* function_;
  ::std::string* version_;
  friend void  protobuf_AddDesc_Documents_2fTypes_2fDocumentTypeDescription_2eproto();
  friend void protobuf_AssignDesc_Documents_2fTypes_2fDocumentTypeDescription_2eproto();
  friend void protobuf_ShutdownFile_Documents_2fTypes_2fDocumentTypeDescription_2eproto();

  void InitAsDefaultInstance();
  static DetectedDocumentType* default_instance_;
};
// -------------------------------------------------------------------

class DetectDocumentTypesResponse : public ::google::protobuf::Message {
 public:
  DetectDocumentTypesResponse();
  virtual ~DetectDocumentTypesResponse();

  DetectDocumentTypesResponse(const DetectDocumentTypesResponse& from);

  inline DetectDocumentTypesResponse& operator=(const DetectDocumentTypesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DetectDocumentTypesResponse& default_instance();

  void Swap(DetectDocumentTypesResponse* other);

  // implements Message ----------------------------------------------

  DetectDocumentTypesResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DetectDocumentTypesResponse& from);
  void MergeFrom(const DetectDocumentTypesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Diadoc.Api.Proto.Documents.Types.DetectedDocumentType DocumentTypes = 1;
  inline int documenttypes_size() const;
  inline void clear_documenttypes();
  static const int kDocumentTypesFieldNumber = 1;
  inline const ::Diadoc::Api::Proto::Documents::Types::DetectedDocumentType& documenttypes(int index) const;
  inline ::Diadoc::Api::Proto::Documents::Types::DetectedDocumentType* mutable_documenttypes(int index);
  inline ::Diadoc::Api::Proto::Documents::Types::DetectedDocumentType* add_documenttypes();
  inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DetectedDocumentType >&
      documenttypes() const;
  inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DetectedDocumentType >*
      mutable_documenttypes();

  // @@protoc_insertion_point(class_scope:Diadoc.Api.Proto.Documents.Types.DetectDocumentTypesResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DetectedDocumentType > documenttypes_;
  friend void  protobuf_AddDesc_Documents_2fTypes_2fDocumentTypeDescription_2eproto();
  friend void protobuf_AssignDesc_Documents_2fTypes_2fDocumentTypeDescription_2eproto();
  friend void protobuf_ShutdownFile_Documents_2fTypes_2fDocumentTypeDescription_2eproto();

  void InitAsDefaultInstance();
  static DetectDocumentTypesResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// DocumentTypeDescription

// required string Name = 1;
inline bool DocumentTypeDescription::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentTypeDescription::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentTypeDescription::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentTypeDescription::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DocumentTypeDescription::name() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.Name)
  return *name_;
}
inline void DocumentTypeDescription::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.Name)
}
inline void DocumentTypeDescription::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.Name)
}
inline void DocumentTypeDescription::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.Name)
}
inline ::std::string* DocumentTypeDescription::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.Name)
  return name_;
}
inline ::std::string* DocumentTypeDescription::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocumentTypeDescription::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.Name)
}

// required string Title = 2;
inline bool DocumentTypeDescription::has_title() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentTypeDescription::set_has_title() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocumentTypeDescription::clear_has_title() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocumentTypeDescription::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& DocumentTypeDescription::title() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.Title)
  return *title_;
}
inline void DocumentTypeDescription::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.Title)
}
inline void DocumentTypeDescription::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.Title)
}
inline void DocumentTypeDescription::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.Title)
}
inline ::std::string* DocumentTypeDescription::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.Title)
  return title_;
}
inline ::std::string* DocumentTypeDescription::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocumentTypeDescription::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.Title)
}

// repeated .Diadoc.Api.Proto.Documents.Types.DocumentDocflow SupportedDocflows = 3;
inline int DocumentTypeDescription::supporteddocflows_size() const {
  return supporteddocflows_.size();
}
inline void DocumentTypeDescription::clear_supporteddocflows() {
  supporteddocflows_.Clear();
}
inline ::Diadoc::Api::Proto::Documents::Types::DocumentDocflow DocumentTypeDescription::supporteddocflows(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.SupportedDocflows)
  return static_cast< ::Diadoc::Api::Proto::Documents::Types::DocumentDocflow >(supporteddocflows_.Get(index));
}
inline void DocumentTypeDescription::set_supporteddocflows(int index, ::Diadoc::Api::Proto::Documents::Types::DocumentDocflow value) {
  assert(::Diadoc::Api::Proto::Documents::Types::DocumentDocflow_IsValid(value));
  supporteddocflows_.Set(index, value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.SupportedDocflows)
}
inline void DocumentTypeDescription::add_supporteddocflows(::Diadoc::Api::Proto::Documents::Types::DocumentDocflow value) {
  assert(::Diadoc::Api::Proto::Documents::Types::DocumentDocflow_IsValid(value));
  supporteddocflows_.Add(value);
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.SupportedDocflows)
}
inline const ::google::protobuf::RepeatedField<int>&
DocumentTypeDescription::supporteddocflows() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.SupportedDocflows)
  return supporteddocflows_;
}
inline ::google::protobuf::RepeatedField<int>*
DocumentTypeDescription::mutable_supporteddocflows() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.SupportedDocflows)
  return &supporteddocflows_;
}

// required bool RequiresFnsRegistration = 4;
inline bool DocumentTypeDescription::has_requiresfnsregistration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DocumentTypeDescription::set_has_requiresfnsregistration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DocumentTypeDescription::clear_has_requiresfnsregistration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DocumentTypeDescription::clear_requiresfnsregistration() {
  requiresfnsregistration_ = false;
  clear_has_requiresfnsregistration();
}
inline bool DocumentTypeDescription::requiresfnsregistration() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.RequiresFnsRegistration)
  return requiresfnsregistration_;
}
inline void DocumentTypeDescription::set_requiresfnsregistration(bool value) {
  set_has_requiresfnsregistration();
  requiresfnsregistration_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.RequiresFnsRegistration)
}

// repeated .Diadoc.Api.Proto.Documents.Types.DocumentFunction Functions = 9;
inline int DocumentTypeDescription::functions_size() const {
  return functions_.size();
}
inline void DocumentTypeDescription::clear_functions() {
  functions_.Clear();
}
inline const ::Diadoc::Api::Proto::Documents::Types::DocumentFunction& DocumentTypeDescription::functions(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.Functions)
  return functions_.Get(index);
}
inline ::Diadoc::Api::Proto::Documents::Types::DocumentFunction* DocumentTypeDescription::mutable_functions(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.Functions)
  return functions_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Documents::Types::DocumentFunction* DocumentTypeDescription::add_functions() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.Functions)
  return functions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentFunction >&
DocumentTypeDescription::functions() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.Functions)
  return functions_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentFunction >*
DocumentTypeDescription::mutable_functions() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription.Functions)
  return &functions_;
}

// -------------------------------------------------------------------

// GetDocumentTypesResponse

// repeated .Diadoc.Api.Proto.Documents.Types.DocumentTypeDescription DocumentTypes = 1;
inline int GetDocumentTypesResponse::documenttypes_size() const {
  return documenttypes_.size();
}
inline void GetDocumentTypesResponse::clear_documenttypes() {
  documenttypes_.Clear();
}
inline const ::Diadoc::Api::Proto::Documents::Types::DocumentTypeDescription& GetDocumentTypesResponse::documenttypes(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.GetDocumentTypesResponse.DocumentTypes)
  return documenttypes_.Get(index);
}
inline ::Diadoc::Api::Proto::Documents::Types::DocumentTypeDescription* GetDocumentTypesResponse::mutable_documenttypes(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Documents.Types.GetDocumentTypesResponse.DocumentTypes)
  return documenttypes_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Documents::Types::DocumentTypeDescription* GetDocumentTypesResponse::add_documenttypes() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Documents.Types.GetDocumentTypesResponse.DocumentTypes)
  return documenttypes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentTypeDescription >&
GetDocumentTypesResponse::documenttypes() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Documents.Types.GetDocumentTypesResponse.DocumentTypes)
  return documenttypes_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentTypeDescription >*
GetDocumentTypesResponse::mutable_documenttypes() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Documents.Types.GetDocumentTypesResponse.DocumentTypes)
  return &documenttypes_;
}

// -------------------------------------------------------------------

// DocumentFunction

// required string Name = 1;
inline bool DocumentFunction::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentFunction::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentFunction::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentFunction::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DocumentFunction::name() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentFunction.Name)
  return *name_;
}
inline void DocumentFunction::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DocumentFunction.Name)
}
inline void DocumentFunction::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Documents.Types.DocumentFunction.Name)
}
inline void DocumentFunction::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Documents.Types.DocumentFunction.Name)
}
inline ::std::string* DocumentFunction::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Documents.Types.DocumentFunction.Name)
  return name_;
}
inline ::std::string* DocumentFunction::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocumentFunction::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Documents.Types.DocumentFunction.Name)
}

// repeated .Diadoc.Api.Proto.Documents.Types.DocumentVersion Versions = 2;
inline int DocumentFunction::versions_size() const {
  return versions_.size();
}
inline void DocumentFunction::clear_versions() {
  versions_.Clear();
}
inline const ::Diadoc::Api::Proto::Documents::Types::DocumentVersion& DocumentFunction::versions(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentFunction.Versions)
  return versions_.Get(index);
}
inline ::Diadoc::Api::Proto::Documents::Types::DocumentVersion* DocumentFunction::mutable_versions(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Documents.Types.DocumentFunction.Versions)
  return versions_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Documents::Types::DocumentVersion* DocumentFunction::add_versions() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Documents.Types.DocumentFunction.Versions)
  return versions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentVersion >&
DocumentFunction::versions() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Documents.Types.DocumentFunction.Versions)
  return versions_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentVersion >*
DocumentFunction::mutable_versions() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Documents.Types.DocumentFunction.Versions)
  return &versions_;
}

// -------------------------------------------------------------------

// DocumentVersion

// required string Version = 1;
inline bool DocumentVersion::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentVersion::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentVersion::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentVersion::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& DocumentVersion::version() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentVersion.Version)
  return *version_;
}
inline void DocumentVersion::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DocumentVersion.Version)
}
inline void DocumentVersion::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Documents.Types.DocumentVersion.Version)
}
inline void DocumentVersion::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Documents.Types.DocumentVersion.Version)
}
inline ::std::string* DocumentVersion::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Documents.Types.DocumentVersion.Version)
  return version_;
}
inline ::std::string* DocumentVersion::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocumentVersion::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Documents.Types.DocumentVersion.Version)
}

// required bool SupportsContentPatching = 2;
inline bool DocumentVersion::has_supportscontentpatching() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentVersion::set_has_supportscontentpatching() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocumentVersion::clear_has_supportscontentpatching() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocumentVersion::clear_supportscontentpatching() {
  supportscontentpatching_ = false;
  clear_has_supportscontentpatching();
}
inline bool DocumentVersion::supportscontentpatching() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentVersion.SupportsContentPatching)
  return supportscontentpatching_;
}
inline void DocumentVersion::set_supportscontentpatching(bool value) {
  set_has_supportscontentpatching();
  supportscontentpatching_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DocumentVersion.SupportsContentPatching)
}

// required bool SupportsEncrypting = 3;
inline bool DocumentVersion::has_supportsencrypting() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DocumentVersion::set_has_supportsencrypting() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DocumentVersion::clear_has_supportsencrypting() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DocumentVersion::clear_supportsencrypting() {
  supportsencrypting_ = false;
  clear_has_supportsencrypting();
}
inline bool DocumentVersion::supportsencrypting() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentVersion.SupportsEncrypting)
  return supportsencrypting_;
}
inline void DocumentVersion::set_supportsencrypting(bool value) {
  set_has_supportsencrypting();
  supportsencrypting_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DocumentVersion.SupportsEncrypting)
}

// repeated .Diadoc.Api.Proto.Documents.Types.DocumentTitle Titles = 4;
inline int DocumentVersion::titles_size() const {
  return titles_.size();
}
inline void DocumentVersion::clear_titles() {
  titles_.Clear();
}
inline const ::Diadoc::Api::Proto::Documents::Types::DocumentTitle& DocumentVersion::titles(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentVersion.Titles)
  return titles_.Get(index);
}
inline ::Diadoc::Api::Proto::Documents::Types::DocumentTitle* DocumentVersion::mutable_titles(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Documents.Types.DocumentVersion.Titles)
  return titles_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Documents::Types::DocumentTitle* DocumentVersion::add_titles() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Documents.Types.DocumentVersion.Titles)
  return titles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentTitle >&
DocumentVersion::titles() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Documents.Types.DocumentVersion.Titles)
  return titles_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentTitle >*
DocumentVersion::mutable_titles() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Documents.Types.DocumentVersion.Titles)
  return &titles_;
}

// required bool IsActual = 5;
inline bool DocumentVersion::has_isactual() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DocumentVersion::set_has_isactual() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DocumentVersion::clear_has_isactual() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DocumentVersion::clear_isactual() {
  isactual_ = false;
  clear_has_isactual();
}
inline bool DocumentVersion::isactual() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentVersion.IsActual)
  return isactual_;
}
inline void DocumentVersion::set_isactual(bool value) {
  set_has_isactual();
  isactual_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DocumentVersion.IsActual)
}

// repeated .Diadoc.Api.Proto.Documents.Types.DocumentWorkflow Workflows = 6;
inline int DocumentVersion::workflows_size() const {
  return workflows_.size();
}
inline void DocumentVersion::clear_workflows() {
  workflows_.Clear();
}
inline const ::Diadoc::Api::Proto::Documents::Types::DocumentWorkflow& DocumentVersion::workflows(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentVersion.Workflows)
  return workflows_.Get(index);
}
inline ::Diadoc::Api::Proto::Documents::Types::DocumentWorkflow* DocumentVersion::mutable_workflows(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Documents.Types.DocumentVersion.Workflows)
  return workflows_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Documents::Types::DocumentWorkflow* DocumentVersion::add_workflows() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Documents.Types.DocumentVersion.Workflows)
  return workflows_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentWorkflow >&
DocumentVersion::workflows() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Documents.Types.DocumentVersion.Workflows)
  return workflows_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentWorkflow >*
DocumentVersion::mutable_workflows() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Documents.Types.DocumentVersion.Workflows)
  return &workflows_;
}

// required bool SupportsPredefinedRecipientTitle = 7;
inline bool DocumentVersion::has_supportspredefinedrecipienttitle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DocumentVersion::set_has_supportspredefinedrecipienttitle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DocumentVersion::clear_has_supportspredefinedrecipienttitle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DocumentVersion::clear_supportspredefinedrecipienttitle() {
  supportspredefinedrecipienttitle_ = false;
  clear_has_supportspredefinedrecipienttitle();
}
inline bool DocumentVersion::supportspredefinedrecipienttitle() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentVersion.SupportsPredefinedRecipientTitle)
  return supportspredefinedrecipienttitle_;
}
inline void DocumentVersion::set_supportspredefinedrecipienttitle(bool value) {
  set_has_supportspredefinedrecipienttitle();
  supportspredefinedrecipienttitle_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DocumentVersion.SupportsPredefinedRecipientTitle)
}

// -------------------------------------------------------------------

// DocumentWorkflow

// required int32 Id = 1;
inline bool DocumentWorkflow::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentWorkflow::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentWorkflow::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentWorkflow::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 DocumentWorkflow::id() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentWorkflow.Id)
  return id_;
}
inline void DocumentWorkflow::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DocumentWorkflow.Id)
}

// required bool IsDefault = 2;
inline bool DocumentWorkflow::has_isdefault() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentWorkflow::set_has_isdefault() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocumentWorkflow::clear_has_isdefault() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocumentWorkflow::clear_isdefault() {
  isdefault_ = false;
  clear_has_isdefault();
}
inline bool DocumentWorkflow::isdefault() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentWorkflow.IsDefault)
  return isdefault_;
}
inline void DocumentWorkflow::set_isdefault(bool value) {
  set_has_isdefault();
  isdefault_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DocumentWorkflow.IsDefault)
}

// -------------------------------------------------------------------

// DocumentTitle

// required int32 Index = 7;
inline bool DocumentTitle::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentTitle::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentTitle::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentTitle::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 DocumentTitle::index() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentTitle.Index)
  return index_;
}
inline void DocumentTitle::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DocumentTitle.Index)
}

// required bool IsFormal = 1;
inline bool DocumentTitle::has_isformal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentTitle::set_has_isformal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocumentTitle::clear_has_isformal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocumentTitle::clear_isformal() {
  isformal_ = false;
  clear_has_isformal();
}
inline bool DocumentTitle::isformal() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentTitle.IsFormal)
  return isformal_;
}
inline void DocumentTitle::set_isformal(bool value) {
  set_has_isformal();
  isformal_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DocumentTitle.IsFormal)
}

// optional string XsdUrl = 2;
inline bool DocumentTitle::has_xsdurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DocumentTitle::set_has_xsdurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DocumentTitle::clear_has_xsdurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DocumentTitle::clear_xsdurl() {
  if (xsdurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xsdurl_->clear();
  }
  clear_has_xsdurl();
}
inline const ::std::string& DocumentTitle::xsdurl() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentTitle.XsdUrl)
  return *xsdurl_;
}
inline void DocumentTitle::set_xsdurl(const ::std::string& value) {
  set_has_xsdurl();
  if (xsdurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xsdurl_ = new ::std::string;
  }
  xsdurl_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DocumentTitle.XsdUrl)
}
inline void DocumentTitle::set_xsdurl(const char* value) {
  set_has_xsdurl();
  if (xsdurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xsdurl_ = new ::std::string;
  }
  xsdurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Documents.Types.DocumentTitle.XsdUrl)
}
inline void DocumentTitle::set_xsdurl(const char* value, size_t size) {
  set_has_xsdurl();
  if (xsdurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xsdurl_ = new ::std::string;
  }
  xsdurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Documents.Types.DocumentTitle.XsdUrl)
}
inline ::std::string* DocumentTitle::mutable_xsdurl() {
  set_has_xsdurl();
  if (xsdurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xsdurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Documents.Types.DocumentTitle.XsdUrl)
  return xsdurl_;
}
inline ::std::string* DocumentTitle::release_xsdurl() {
  clear_has_xsdurl();
  if (xsdurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = xsdurl_;
    xsdurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocumentTitle::set_allocated_xsdurl(::std::string* xsdurl) {
  if (xsdurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete xsdurl_;
  }
  if (xsdurl) {
    set_has_xsdurl();
    xsdurl_ = xsdurl;
  } else {
    clear_has_xsdurl();
    xsdurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Documents.Types.DocumentTitle.XsdUrl)
}

// optional string UserDataXsdUrl = 5;
inline bool DocumentTitle::has_userdataxsdurl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DocumentTitle::set_has_userdataxsdurl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DocumentTitle::clear_has_userdataxsdurl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DocumentTitle::clear_userdataxsdurl() {
  if (userdataxsdurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userdataxsdurl_->clear();
  }
  clear_has_userdataxsdurl();
}
inline const ::std::string& DocumentTitle::userdataxsdurl() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentTitle.UserDataXsdUrl)
  return *userdataxsdurl_;
}
inline void DocumentTitle::set_userdataxsdurl(const ::std::string& value) {
  set_has_userdataxsdurl();
  if (userdataxsdurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userdataxsdurl_ = new ::std::string;
  }
  userdataxsdurl_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DocumentTitle.UserDataXsdUrl)
}
inline void DocumentTitle::set_userdataxsdurl(const char* value) {
  set_has_userdataxsdurl();
  if (userdataxsdurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userdataxsdurl_ = new ::std::string;
  }
  userdataxsdurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Documents.Types.DocumentTitle.UserDataXsdUrl)
}
inline void DocumentTitle::set_userdataxsdurl(const char* value, size_t size) {
  set_has_userdataxsdurl();
  if (userdataxsdurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userdataxsdurl_ = new ::std::string;
  }
  userdataxsdurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Documents.Types.DocumentTitle.UserDataXsdUrl)
}
inline ::std::string* DocumentTitle::mutable_userdataxsdurl() {
  set_has_userdataxsdurl();
  if (userdataxsdurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userdataxsdurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Documents.Types.DocumentTitle.UserDataXsdUrl)
  return userdataxsdurl_;
}
inline ::std::string* DocumentTitle::release_userdataxsdurl() {
  clear_has_userdataxsdurl();
  if (userdataxsdurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = userdataxsdurl_;
    userdataxsdurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocumentTitle::set_allocated_userdataxsdurl(::std::string* userdataxsdurl) {
  if (userdataxsdurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete userdataxsdurl_;
  }
  if (userdataxsdurl) {
    set_has_userdataxsdurl();
    userdataxsdurl_ = userdataxsdurl;
  } else {
    clear_has_userdataxsdurl();
    userdataxsdurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Documents.Types.DocumentTitle.UserDataXsdUrl)
}

// required .Diadoc.Api.Proto.Documents.Types.SignerInfo SignerInfo = 6;
inline bool DocumentTitle::has_signerinfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DocumentTitle::set_has_signerinfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DocumentTitle::clear_has_signerinfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DocumentTitle::clear_signerinfo() {
  if (signerinfo_ != NULL) signerinfo_->::Diadoc::Api::Proto::Documents::Types::SignerInfo::Clear();
  clear_has_signerinfo();
}
inline const ::Diadoc::Api::Proto::Documents::Types::SignerInfo& DocumentTitle::signerinfo() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentTitle.SignerInfo)
  return signerinfo_ != NULL ? *signerinfo_ : *default_instance_->signerinfo_;
}
inline ::Diadoc::Api::Proto::Documents::Types::SignerInfo* DocumentTitle::mutable_signerinfo() {
  set_has_signerinfo();
  if (signerinfo_ == NULL) signerinfo_ = new ::Diadoc::Api::Proto::Documents::Types::SignerInfo;
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Documents.Types.DocumentTitle.SignerInfo)
  return signerinfo_;
}
inline ::Diadoc::Api::Proto::Documents::Types::SignerInfo* DocumentTitle::release_signerinfo() {
  clear_has_signerinfo();
  ::Diadoc::Api::Proto::Documents::Types::SignerInfo* temp = signerinfo_;
  signerinfo_ = NULL;
  return temp;
}
inline void DocumentTitle::set_allocated_signerinfo(::Diadoc::Api::Proto::Documents::Types::SignerInfo* signerinfo) {
  delete signerinfo_;
  signerinfo_ = signerinfo;
  if (signerinfo) {
    set_has_signerinfo();
  } else {
    clear_has_signerinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Documents.Types.DocumentTitle.SignerInfo)
}

// repeated .Diadoc.Api.Proto.Documents.Types.DocumentMetadataItem MetadataItems = 3;
inline int DocumentTitle::metadataitems_size() const {
  return metadataitems_.size();
}
inline void DocumentTitle::clear_metadataitems() {
  metadataitems_.Clear();
}
inline const ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItem& DocumentTitle::metadataitems(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentTitle.MetadataItems)
  return metadataitems_.Get(index);
}
inline ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItem* DocumentTitle::mutable_metadataitems(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Documents.Types.DocumentTitle.MetadataItems)
  return metadataitems_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItem* DocumentTitle::add_metadataitems() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Documents.Types.DocumentTitle.MetadataItems)
  return metadataitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItem >&
DocumentTitle::metadataitems() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Documents.Types.DocumentTitle.MetadataItems)
  return metadataitems_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItem >*
DocumentTitle::mutable_metadataitems() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Documents.Types.DocumentTitle.MetadataItems)
  return &metadataitems_;
}

// repeated .Diadoc.Api.Proto.Documents.Types.DocumentMetadataItem EncryptedMetadataItems = 4;
inline int DocumentTitle::encryptedmetadataitems_size() const {
  return encryptedmetadataitems_.size();
}
inline void DocumentTitle::clear_encryptedmetadataitems() {
  encryptedmetadataitems_.Clear();
}
inline const ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItem& DocumentTitle::encryptedmetadataitems(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentTitle.EncryptedMetadataItems)
  return encryptedmetadataitems_.Get(index);
}
inline ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItem* DocumentTitle::mutable_encryptedmetadataitems(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Documents.Types.DocumentTitle.EncryptedMetadataItems)
  return encryptedmetadataitems_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItem* DocumentTitle::add_encryptedmetadataitems() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Documents.Types.DocumentTitle.EncryptedMetadataItems)
  return encryptedmetadataitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItem >&
DocumentTitle::encryptedmetadataitems() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Documents.Types.DocumentTitle.EncryptedMetadataItems)
  return encryptedmetadataitems_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItem >*
DocumentTitle::mutable_encryptedmetadataitems() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Documents.Types.DocumentTitle.EncryptedMetadataItems)
  return &encryptedmetadataitems_;
}

// -------------------------------------------------------------------

// SignerInfo

// required .Diadoc.Api.Proto.Documents.Types.SignerType SignerType = 1;
inline bool SignerInfo::has_signertype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignerInfo::set_has_signertype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignerInfo::clear_has_signertype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignerInfo::clear_signertype() {
  signertype_ = 0;
  clear_has_signertype();
}
inline ::Diadoc::Api::Proto::Documents::Types::SignerType SignerInfo::signertype() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.SignerInfo.SignerType)
  return static_cast< ::Diadoc::Api::Proto::Documents::Types::SignerType >(signertype_);
}
inline void SignerInfo::set_signertype(::Diadoc::Api::Proto::Documents::Types::SignerType value) {
  assert(::Diadoc::Api::Proto::Documents::Types::SignerType_IsValid(value));
  set_has_signertype();
  signertype_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.SignerInfo.SignerType)
}

// required .Diadoc.Api.Proto.Invoicing.Signers.DocumentTitleType ExtendedDocumentTitleType = 2 [default = Absent];
inline bool SignerInfo::has_extendeddocumenttitletype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignerInfo::set_has_extendeddocumenttitletype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignerInfo::clear_has_extendeddocumenttitletype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignerInfo::clear_extendeddocumenttitletype() {
  extendeddocumenttitletype_ = -1;
  clear_has_extendeddocumenttitletype();
}
inline ::Diadoc::Api::Proto::Invoicing::Signers::DocumentTitleType SignerInfo::extendeddocumenttitletype() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.SignerInfo.ExtendedDocumentTitleType)
  return static_cast< ::Diadoc::Api::Proto::Invoicing::Signers::DocumentTitleType >(extendeddocumenttitletype_);
}
inline void SignerInfo::set_extendeddocumenttitletype(::Diadoc::Api::Proto::Invoicing::Signers::DocumentTitleType value) {
  assert(::Diadoc::Api::Proto::Invoicing::Signers::DocumentTitleType_IsValid(value));
  set_has_extendeddocumenttitletype();
  extendeddocumenttitletype_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.SignerInfo.ExtendedDocumentTitleType)
}

// -------------------------------------------------------------------

// DocumentMetadataItem

// required string Id = 1;
inline bool DocumentMetadataItem::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentMetadataItem::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentMetadataItem::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentMetadataItem::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& DocumentMetadataItem::id() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentMetadataItem.Id)
  return *id_;
}
inline void DocumentMetadataItem::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DocumentMetadataItem.Id)
}
inline void DocumentMetadataItem::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Documents.Types.DocumentMetadataItem.Id)
}
inline void DocumentMetadataItem::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Documents.Types.DocumentMetadataItem.Id)
}
inline ::std::string* DocumentMetadataItem::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Documents.Types.DocumentMetadataItem.Id)
  return id_;
}
inline ::std::string* DocumentMetadataItem::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DocumentMetadataItem::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Documents.Types.DocumentMetadataItem.Id)
}

// required .Diadoc.Api.Proto.Documents.Types.DocumentMetadataItemType Type = 2;
inline bool DocumentMetadataItem::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentMetadataItem::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocumentMetadataItem::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocumentMetadataItem::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItemType DocumentMetadataItem::type() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentMetadataItem.Type)
  return static_cast< ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItemType >(type_);
}
inline void DocumentMetadataItem::set_type(::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItemType value) {
  assert(::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItemType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DocumentMetadataItem.Type)
}

// required bool IsRequired = 3;
inline bool DocumentMetadataItem::has_isrequired() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DocumentMetadataItem::set_has_isrequired() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DocumentMetadataItem::clear_has_isrequired() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DocumentMetadataItem::clear_isrequired() {
  isrequired_ = false;
  clear_has_isrequired();
}
inline bool DocumentMetadataItem::isrequired() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentMetadataItem.IsRequired)
  return isrequired_;
}
inline void DocumentMetadataItem::set_isrequired(bool value) {
  set_has_isrequired();
  isrequired_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DocumentMetadataItem.IsRequired)
}

// required .Diadoc.Api.Proto.Documents.Types.DocumentMetadataSource Source = 4;
inline bool DocumentMetadataItem::has_source() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DocumentMetadataItem::set_has_source() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DocumentMetadataItem::clear_has_source() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DocumentMetadataItem::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataSource DocumentMetadataItem::source() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DocumentMetadataItem.Source)
  return static_cast< ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataSource >(source_);
}
inline void DocumentMetadataItem::set_source(::Diadoc::Api::Proto::Documents::Types::DocumentMetadataSource value) {
  assert(::Diadoc::Api::Proto::Documents::Types::DocumentMetadataSource_IsValid(value));
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DocumentMetadataItem.Source)
}

// -------------------------------------------------------------------

// DetectedDocumentType

// required string TypeNamedId = 1;
inline bool DetectedDocumentType::has_typenamedid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DetectedDocumentType::set_has_typenamedid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DetectedDocumentType::clear_has_typenamedid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DetectedDocumentType::clear_typenamedid() {
  if (typenamedid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    typenamedid_->clear();
  }
  clear_has_typenamedid();
}
inline const ::std::string& DetectedDocumentType::typenamedid() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DetectedDocumentType.TypeNamedId)
  return *typenamedid_;
}
inline void DetectedDocumentType::set_typenamedid(const ::std::string& value) {
  set_has_typenamedid();
  if (typenamedid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    typenamedid_ = new ::std::string;
  }
  typenamedid_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DetectedDocumentType.TypeNamedId)
}
inline void DetectedDocumentType::set_typenamedid(const char* value) {
  set_has_typenamedid();
  if (typenamedid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    typenamedid_ = new ::std::string;
  }
  typenamedid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Documents.Types.DetectedDocumentType.TypeNamedId)
}
inline void DetectedDocumentType::set_typenamedid(const char* value, size_t size) {
  set_has_typenamedid();
  if (typenamedid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    typenamedid_ = new ::std::string;
  }
  typenamedid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Documents.Types.DetectedDocumentType.TypeNamedId)
}
inline ::std::string* DetectedDocumentType::mutable_typenamedid() {
  set_has_typenamedid();
  if (typenamedid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    typenamedid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Documents.Types.DetectedDocumentType.TypeNamedId)
  return typenamedid_;
}
inline ::std::string* DetectedDocumentType::release_typenamedid() {
  clear_has_typenamedid();
  if (typenamedid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = typenamedid_;
    typenamedid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DetectedDocumentType::set_allocated_typenamedid(::std::string* typenamedid) {
  if (typenamedid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete typenamedid_;
  }
  if (typenamedid) {
    set_has_typenamedid();
    typenamedid_ = typenamedid;
  } else {
    clear_has_typenamedid();
    typenamedid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Documents.Types.DetectedDocumentType.TypeNamedId)
}

// required string Function = 2;
inline bool DetectedDocumentType::has_function() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DetectedDocumentType::set_has_function() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DetectedDocumentType::clear_has_function() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DetectedDocumentType::clear_function() {
  if (function_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_->clear();
  }
  clear_has_function();
}
inline const ::std::string& DetectedDocumentType::function() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DetectedDocumentType.Function)
  return *function_;
}
inline void DetectedDocumentType::set_function(const ::std::string& value) {
  set_has_function();
  if (function_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_ = new ::std::string;
  }
  function_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DetectedDocumentType.Function)
}
inline void DetectedDocumentType::set_function(const char* value) {
  set_has_function();
  if (function_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_ = new ::std::string;
  }
  function_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Documents.Types.DetectedDocumentType.Function)
}
inline void DetectedDocumentType::set_function(const char* value, size_t size) {
  set_has_function();
  if (function_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_ = new ::std::string;
  }
  function_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Documents.Types.DetectedDocumentType.Function)
}
inline ::std::string* DetectedDocumentType::mutable_function() {
  set_has_function();
  if (function_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Documents.Types.DetectedDocumentType.Function)
  return function_;
}
inline ::std::string* DetectedDocumentType::release_function() {
  clear_has_function();
  if (function_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = function_;
    function_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DetectedDocumentType::set_allocated_function(::std::string* function) {
  if (function_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete function_;
  }
  if (function) {
    set_has_function();
    function_ = function;
  } else {
    clear_has_function();
    function_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Documents.Types.DetectedDocumentType.Function)
}

// required string Version = 3;
inline bool DetectedDocumentType::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DetectedDocumentType::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DetectedDocumentType::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DetectedDocumentType::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& DetectedDocumentType::version() const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DetectedDocumentType.Version)
  return *version_;
}
inline void DetectedDocumentType::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:Diadoc.Api.Proto.Documents.Types.DetectedDocumentType.Version)
}
inline void DetectedDocumentType::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:Diadoc.Api.Proto.Documents.Types.DetectedDocumentType.Version)
}
inline void DetectedDocumentType::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Diadoc.Api.Proto.Documents.Types.DetectedDocumentType.Version)
}
inline ::std::string* DetectedDocumentType::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Documents.Types.DetectedDocumentType.Version)
  return version_;
}
inline ::std::string* DetectedDocumentType::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DetectedDocumentType::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Diadoc.Api.Proto.Documents.Types.DetectedDocumentType.Version)
}

// -------------------------------------------------------------------

// DetectDocumentTypesResponse

// repeated .Diadoc.Api.Proto.Documents.Types.DetectedDocumentType DocumentTypes = 1;
inline int DetectDocumentTypesResponse::documenttypes_size() const {
  return documenttypes_.size();
}
inline void DetectDocumentTypesResponse::clear_documenttypes() {
  documenttypes_.Clear();
}
inline const ::Diadoc::Api::Proto::Documents::Types::DetectedDocumentType& DetectDocumentTypesResponse::documenttypes(int index) const {
  // @@protoc_insertion_point(field_get:Diadoc.Api.Proto.Documents.Types.DetectDocumentTypesResponse.DocumentTypes)
  return documenttypes_.Get(index);
}
inline ::Diadoc::Api::Proto::Documents::Types::DetectedDocumentType* DetectDocumentTypesResponse::mutable_documenttypes(int index) {
  // @@protoc_insertion_point(field_mutable:Diadoc.Api.Proto.Documents.Types.DetectDocumentTypesResponse.DocumentTypes)
  return documenttypes_.Mutable(index);
}
inline ::Diadoc::Api::Proto::Documents::Types::DetectedDocumentType* DetectDocumentTypesResponse::add_documenttypes() {
  // @@protoc_insertion_point(field_add:Diadoc.Api.Proto.Documents.Types.DetectDocumentTypesResponse.DocumentTypes)
  return documenttypes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DetectedDocumentType >&
DetectDocumentTypesResponse::documenttypes() const {
  // @@protoc_insertion_point(field_list:Diadoc.Api.Proto.Documents.Types.DetectDocumentTypesResponse.DocumentTypes)
  return documenttypes_;
}
inline ::google::protobuf::RepeatedPtrField< ::Diadoc::Api::Proto::Documents::Types::DetectedDocumentType >*
DetectDocumentTypesResponse::mutable_documenttypes() {
  // @@protoc_insertion_point(field_mutable_list:Diadoc.Api.Proto.Documents.Types.DetectDocumentTypesResponse.DocumentTypes)
  return &documenttypes_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Types
}  // namespace Documents
}  // namespace Proto
}  // namespace Api
}  // namespace Diadoc

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Diadoc::Api::Proto::Documents::Types::DocumentDocflow> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Diadoc::Api::Proto::Documents::Types::DocumentDocflow>() {
  return ::Diadoc::Api::Proto::Documents::Types::DocumentDocflow_descriptor();
}
template <> struct is_proto_enum< ::Diadoc::Api::Proto::Documents::Types::SignerType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Diadoc::Api::Proto::Documents::Types::SignerType>() {
  return ::Diadoc::Api::Proto::Documents::Types::SignerType_descriptor();
}
template <> struct is_proto_enum< ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItemType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItemType>() {
  return ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataItemType_descriptor();
}
template <> struct is_proto_enum< ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataSource> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataSource>() {
  return ::Diadoc::Api::Proto::Documents::Types::DocumentMetadataSource_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Documents_2fTypes_2fDocumentTypeDescription_2eproto__INCLUDED
